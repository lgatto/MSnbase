<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>MSnbase: MS data processing, visualisation and quantification • MSnbase</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.7.1/clipboard.min.js" integrity="sha384-cV+rhyOuRHc9Ub/91rihWcGmMmCXDeksTtCihMupQHSsi8GIIRDG0ThDc3HGQFJ3" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../jquery.sticky-kit.min.js"></script><script src="../pkgdown.js"></script><meta property="og:title" content="MSnbase: MS data processing, visualisation and quantification">
<meta property="og:description" content="">
<meta name="twitter:card" content="summary">
<!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">MSnbase</a>
        <span class="label label-default" data-toggle="tooltip" data-placement="bottom" title="Released package">2.7.1</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/MSnbase-centroiding.html">MSnbase: centroiding of profile-mode MS data</a>
    </li>
    <li>
      <a href="../articles/MSnbase-demo.html">MSnbase: MS data processing, visualisation and quantification</a>
    </li>
    <li>
      <a href="../articles/MSnbase-development.html">A short introduction to *MSnbase* development</a>
    </li>
    <li>
      <a href="../articles/MSnbase-io.html">MSnbase IO capabilities</a>
    </li>
    <li>
      <a href="../articles/benchmarking.html">MSnbase2 benchmarking</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/lgatto/MSnbase">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1>MSnbase: MS data processing, visualisation and quantification</h1>
                        <h4 class="author">Laurent Gatto</h4>
                                    <h4 class="author">Johannes Rainer</h4>
                                    <h4 class="author">Sebastian Gibb</h4>
                        
      
      <small class="dont-index">Source: <a href="https://github.com/lgatto/MSnbase/blob/master/vignettes/MSnbase-demo.Rmd"><code>vignettes/MSnbase-demo.Rmd</code></a></small>
      <div class="hidden name"><code>MSnbase-demo.Rmd</code></div>

    </div>

    
        <div class="abstract">
      <p class="abstract">Abstract</p>
      <p>This vignette describes the functionality implemented in the <em>MSnbase</em> package. <em>MSnbase</em> aims at (1) facilitating the import, processing, visualisation and quantification of mass spectrometry data into the R environment <span class="citation">(R Development Core Team 2011)</span> by providing specific data classes and methods and (2) enabling the utilisation of throughput-high data analysis pipelines provided by the Bioconductor <span class="citation">(Gentleman et al. 2004)</span> project.</p>
    </div>
    
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function() {
  document.querySelector("h1").className = "title";
});
</script><script type="text/javascript">
document.addEventListener("DOMContentLoaded", function() {
  var links = document.links;  
  for (var i = 0, linksLength = links.length; i < linksLength; i++)
    if (links[i].hostname != window.location.hostname)
      links[i].target = '_blank';
});
</script><div id="foreword" class="section level1 unnumbered">
<h1 class="hasAnchor">
<a href="#foreword" class="anchor"></a>Foreword</h1>
<p><a href="http://bioconductor.org/packages/MSnbase"><em>MSnbase</em></a> is under active development; current functionality is evolving and new features will be added. This software is free and open-source software. If you use it, please support the project by citing it in publications:</p>
<blockquote>
<p>Gatto L, Lilley KS. MSnbase-an R/Bioconductor package for isobaric tagged mass spectrometry data visualization, processing and quantitation. Bioinformatics. 2012 Jan 15;28(2):288-9. doi: <a href="https://doi.org/10.1093/bioinformatics/btr645">10.1093/bioinformatics/btr645</a>. PMID: <a href="https://www.ncbi.nlm.nih.gov/pubmed/22113085">22113085</a>.</p>
</blockquote>
</div>
<div id="questions-and-bugs" class="section level1 unnumbered">
<h1 class="hasAnchor">
<a href="#questions-and-bugs" class="anchor"></a>Questions and bugs</h1>
<p>For bugs, typos, suggestions or other questions, please file an issue in our tracking system (<a href="https://github.com/lgatto/MSnbase/issues" class="uri">https://github.com/lgatto/MSnbase/issues</a>) providing as much information as possible, a reproducible example and the output of <code>sessionInfo()</code>.</p>
<p>If you don’t have a GitHub account or wish to reach a broader audience for general questions about proteomics analysis using R, you may want to use the Bioconductor support site: <a href="https://support.bioconductor.org/" class="uri">https://support.bioconductor.org/</a>.</p>
</div>
<div id="sec:intro" class="section level1">
<h1 class="hasAnchor">
<a href="#sec:intro" class="anchor"></a>Introduction</h1>
<p><em><a href="http://bioconductor.org/packages/MSnbase">MSnbase</a></em> <span class="citation">(L. Gatto and Lilley 2012)</span> aims are providing a reproducible research framework to proteomics data analysis. It should allow researcher to easily mine mass spectrometry data, explore the data and its statistical properties and visually display these.</p>
<p><em><a href="http://bioconductor.org/packages/MSnbase">MSnbase</a></em> also aims at being compatible with the infrastructure implemented in Bioconductor, in particular <em><a href="http://bioconductor.org/packages/Biobase">Biobase</a></em>. As such, classes developed specifically for proteomics mass spectrometry data are based on the <em>eSet</em> and <em>ExpressionSet</em> classes. The main goal is to assure seamless compatibility with existing meta data structure, accessor methods and normalisation techniques.</p>
<p>This vignette illustrates <em><a href="http://bioconductor.org/packages/MSnbase">MSnbase</a></em> utility using a dummy data sets provided with the package without describing the underlying data structures. More details can be found in the package, classes, method and function documentations. A description of the classes is provided in the <em>MSnbase-development</em> vignette<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>.</p>
<div id="speed-and-memory-requirements" class="section level2">
<h2 class="hasAnchor">
<a href="#speed-and-memory-requirements" class="anchor"></a>Speed and memory requirements</h2>
<p>Raw mass spectrometry file are generally several hundreds of MB large and most of this is used for binary raw spectrum data. As such, data containers can easily grow very large and thus require large amounts of RAM. This requirement is being tackled by avoiding to load the raw data into memory and using on-disk random access to the content of <code>mzXML</code>/<code>mzML</code> data files on demand. When focusing on reporter ion quantitation, a direct solution for this is to trim the spectra using the <code>trimMz</code> method to select the area of interest and thus substantially reduce the size of the <code>Spectrum</code> objects. This is illustrated in section @ref(sec:trim).</p>
<p>The independent handling of spectra is ideally suited for parallel processing. The <code>quantify</code> method now performs reporter peaks quantitation in parallel. More functions are being updated.</p>
<p>Finally, recent developmenets in version 2 of the package have solved the memory issue by implementing and <em>on-disk</em> version the of data class storing raw data (<em>MSnExp</em>, see section @ref(sec:msnexp)), where the spectra a accessed on-disk only when required. The <em>benchmarking</em> vignette compares the on-disk and in-memory implemenatations<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>.</p>
</div>
</div>
<div id="sec:data" class="section level1">
<h1 class="hasAnchor">
<a href="#sec:data" class="anchor"></a>Data structure and content</h1>
<div id="sec:io" class="section level2">
<h2 class="hasAnchor">
<a href="#sec:io" class="anchor"></a>Importing experiments</h2>
<p><em><a href="http://bioconductor.org/packages/MSnbase">MSnbase</a></em> is able to import raw MS data stored in one of the <code>XML</code>-based formats as well as peak lists in the <code>mfg</code> format<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>.</p>
<p><strong>Raw data</strong> The <code>XML</code>-based formats, <code>mzXML</code> <span class="citation">(Pedrioli et al. 2004)</span>, <code>mzData</code> <span class="citation">(Orchard et al. 2007)</span> and <code>mzML</code> <span class="citation">(Martens et al. 2010)</span> can be imported with the <code>readMSData</code> function, as illustrated below (see <code><a href="../reference/readMSData.html">?readMSData</a></code> for more details). To make use of the new <em>on-disk</em> implementation, set <code>mode = "onDisk"</code> in <code>readMSData</code> rather than using the default <code>mode = "inMemory"</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">file &lt;-<span class="st"> </span><span class="kw">dir</span>(<span class="kw">system.file</span>(<span class="dt">package =</span> <span class="st">"MSnbase"</span>, <span class="dt">dir =</span> <span class="st">"extdata"</span>),
            <span class="dt">full.names =</span> <span class="ot">TRUE</span>, <span class="dt">pattern =</span> <span class="st">"mzXML$"</span>)
rawdata &lt;-<span class="st"> </span><span class="kw"><a href="../reference/readMSData.html">readMSData</a></span>(file, <span class="dt">msLevel =</span> <span class="dv">2</span>, <span class="dt">verbose =</span> <span class="ot">FALSE</span>)</code></pre></div>
<pre><code>## Warning: The direct support for chromatogram info is only available in mzML
## format.</code></pre>
<p>Only spectra of a given MS level can be loaded at a time by setting the <code>msLevel</code> parameter accordingly in <code>readMSData</code> and <em>in-memory</em> data. In this document, we will use the <code>itraqdata</code> data set, provided with <em><a href="http://bioconductor.org/packages/MSnbase">MSnbase</a></em>. It includes feature metadata, accessible with the <code>fData</code> accessor. The metadata includes identification data for the 55 MS2 spectra.</p>
<p><strong>MSnbase 2.0</strong> Version 2.0 and later of <em><a href="http://bioconductor.org/packages/MSnbase">MSnbase</a></em> use a new <em>on-disk</em> data storage model (see the <em>benchmarking</em> vignette for more details). The new data backend is compatible with the orignal <em>in-memory</em> model. To make use of the new infrastructure, read your raw data by setting the <code>mode</code> argument to <code>"onDisk"</code> (the default in <code>"inMemory"</code>). The new <em>on-disk</em> implementation supports several MS levels in a single raw data object. All existing operations work irrespective of the backend.</p>
<p><strong>Peak lists</strong> Peak lists can often be exported after spectrum processing from vendor-specific software and are also used as input to search engines. Peak lists in <code>mgf</code> format can be imported with the function <code>readMgfData</code> (see <code><a href="../reference/readMgfData.html">?readMgfData</a></code> for details) to create experiment objects. Experiments or individual spectra can be exported to an <code>mgf</code> file with the <code>writeMgfData</code> methods (see <code><a href="../reference/writeMgfData-methods.html">?writeMgfData</a></code> for details and examples).</p>
<p><strong>Experiments with multiple runs</strong> Although it is possible to load and process multiple files serially and later merge the resulting quantitation data as show in section @ref(sec:combine), it is also feasible to load several raw data files at once. Here, we report the analysis of an LC-MSMS experiment were 14 liquid chromatography (LC) fractions were loaded using <code>readMSData</code> on a 32-cores servers with 128 Gb of RAM. It took about 90 minutes to read the 14 uncentroided <code>mzXML</code> raw files (4.9 Gb on disk in total) and create a 3.3 Gb raw data object (an <em>MSnExp</em> instance, see next section). Quantitation of 9 reporter ions (<em>iTRAQ9</em> object, see @ref(sec:reporterions)) for 88690 features was performed in parallel on 16 processors<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a> and took 76 minutes. The resulting quantitation data was only 22.1 Mb and could easily be further processed and analysed on a standard laptop computer. These number as based on the older <em>in-memory</em> implementation. As shown in the <em>benchmarking</em> vignette, using <em>on-disk</em> data greatly reduces memory requirement and computation time.</p>
<p>See also section @ref(sec:io2) to import quantitative data stored in spreadsheets into R for further processing using <em><a href="http://bioconductor.org/packages/MSnbase">MSnbase</a></em>. The <em>MSnbase-io</em>vignette[in R, open it with <code><a href="../articles/MSnbase-io.html">vignette("MSnbase-io")</a></code> or read it online <a href="https://bioconductor.org/packages/devel/bioc/vignettes/MSnbase/inst/doc/MSnbase-io.html">here</a>] gives a general overview of <em><a href="http://bioconductor.org/packages/MSnbase">MSnbase</a></em>’s input/ouput capabilites.</p>
<p>See section @ref(sec:io3) for importing chromatographic data of SRM/MRM experiments.</p>
</div>
<div id="exporting-experimentsms-data" class="section level2">
<h2 class="hasAnchor">
<a href="#exporting-experimentsms-data" class="anchor"></a>Exporting experiments/MS data</h2>
<p><code>MSnbase</code> supports also to write <code>MSnExp</code> or <code>OnDiskMSnExp</code> objects to <code>mzML</code> or <code>mzXML</code> files using the <code>writeMSData</code> function. This is specifically useful in workflows in which the MS data was heavily manipulated. Presently, each sample/file is exported into one file.</p>
<p>Below we write the data in <code>mzML</code> format to a temporary file. By setting the optional parameter <code>copy = TRUE</code> general metadata (such as instrument info or all data processing descriptions) are copied over from the originating file.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/writeMSData.html">writeMSData</a></span>(rawdata, <span class="dt">file =</span> <span class="kw">paste0</span>(<span class="kw">tempfile</span>(), <span class="st">".mzML"</span>), <span class="dt">copy =</span> <span class="ot">TRUE</span>)</code></pre></div>
</div>
<div id="sec:msnexp" class="section level2">
<h2 class="hasAnchor">
<a href="#sec:msnexp" class="anchor"></a>MS experiments</h2>
<p>Raw data is contained in <em>MSnExp</em> objects, that stores all the spectra of an experiment, as defined by one or multiple raw data files.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(<span class="st">"MSnbase"</span>)
itraqdata</code></pre></div>
<pre><code>## MSn experiment data ("MSnExp")
## Object size in memory: 1.9 Mb
## - - - Spectra data - - -
##  MS level(s): 2 
##  Number of spectra: 55 
##  MSn retention times: 19:9 - 50:18 minutes
## - - - Processing information - - -
## Data loaded: Wed May 11 18:54:39 2011 
## Updated from version 0.3.0 to 0.3.1 [Fri Jul  8 20:23:25 2016] 
##  MSnbase version: 1.1.22 
## - - - Meta data  - - -
## phenoData
##   rowNames: 1
##   varLabels: sampleNames sampleNumbers
##   varMetadata: labelDescription
## Loaded from:
##   dummyiTRAQ.mzXML 
## protocolData: none
## featureData
##   featureNames: X1 X10 ... X9 (55 total)
##   fvarLabels: spectrum ProteinAccession ProteinDescription
##     PeptideSequence
##   fvarMetadata: labelDescription
## experimentData: use 'experimentData(object)'</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(<span class="kw">fData</span>(itraqdata))</code></pre></div>
<pre><code>##     spectrum ProteinAccession                       ProteinDescription
## X1         1              BSA                     bovine serum albumin
## X10       10          ECA1422 glucose-1-phosphate cytidylyltransferase
## X11       11          ECA4030         50S ribosomal subunit protein L4
## X12       12          ECA3882                   chaperone protein DnaK
## X13       13          ECA1364      succinyl-CoA synthetase alpha chain
## X14       14          ECA0871              NADP-dependent malic enzyme
##     PeptideSequence
## X1           NYQEAK
## X10 VTLVDTGEHSMTGGR
## X11           SPIWR
## X12        TAIDDALK
## X13          SILINK
## X14    DFEVVNNESDPR</code></pre>
<p>As illustrated above, showing the experiment textually displays it’s content:</p>
<ul>
<li><p>Information about the raw data, i.e. the spectra.</p></li>
<li><p>Specific information about the experiment processing<a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a> and package version. This slot can be accessed with the <code>processingData</code> method.</p></li>
<li><p>Other meta data, including experimental phenotype, file name(s) used to import the data, protocol data, information about features (individual spectra here) and experiment data. Most of these are implemented as in the <em>eSet</em> class and are described in more details in their respective manual pages. See <code><a href="../reference/MSnExp-class.html">?MSnExp</a></code> and references therein for additional background information.</p></li>
</ul>
<p>The experiment meta data associated with an <em>MSnExp</em> experiment is of class <em>MIAPE</em>. It stores general information about the experiment as well as MIAPE (Minimum Information About a Proteomics Experiment) information <span class="citation">(C. F. Taylor et al. 2007, <span class="citation">Taylor et al. (2008)</span>)</span>. This meta-data can be accessed with the <code>experimentData</code> method. When available, a summary of MIAPE-MS data can be printed with the <code>msInfo</code> method. See <code><a href="../reference/MIAPE-class.html">?MIAPE</a></code> for more details.</p>
</div>
<div id="sec:spectra" class="section level2">
<h2 class="hasAnchor">
<a href="#sec:spectra" class="anchor"></a>Spectra objects</h2>
<p>The raw data is composed of the 55 MS spectra. The spectra are named individually (X1, X10, X11, X12, X13, X14, …) and stored in a <code>environment</code>. They can be accessed individually with <code>itraqdata[["X1"]]</code> or <code>itraqdata[[1]]</code>, or as a list with <code><a href="../reference/pSet-class.html">spectra(itraqdata)</a></code>. As we have loaded our experiment specifying <code>msLevel=2</code>, the spectra will all be of level 2 (or higher, if available).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sp &lt;-<span class="st"> </span>itraqdata[[<span class="st">"X1"</span>]]
sp</code></pre></div>
<pre><code>## Object of class "Spectrum2"
##  Precursor: 520.7833 
##  Retention time: 19:9 
##  Charge: 2 
##  MSn level: 2 
##  Peaks count: 1922 
##  Total ion count: 26413754</code></pre>
<p>Attributes of individual spectra or of all spectra of an experiment can be accessed with their respective methods: <code>precursorCharge</code> for the precursor charge, <code>rtime</code> for the retention time, <code>mz</code> for the MZ values, <code>intensity</code> for the intensities, … see the <em>Spectrum</em>, <em>Spectrum1</em> and <em>Spectrum2</em> manuals for more details.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/Spectrum-class.html">peaksCount</a></span>(sp)</code></pre></div>
<pre><code>## [1] 1922</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(<span class="kw"><a href="../reference/Spectrum-class.html">peaksCount</a></span>(itraqdata))</code></pre></div>
<pre><code>##   X1  X10  X11  X12  X13  X14 
## 1922 1376 1571 2397 2574 1829</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/Spectrum-class.html">rtime</a></span>(sp)</code></pre></div>
<pre><code>## [1] 1149.31</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(<span class="kw"><a href="../reference/Spectrum-class.html">rtime</a></span>(itraqdata))</code></pre></div>
<pre><code>##      X1     X10     X11     X12     X13     X14 
## 1149.31 1503.03 1663.61 1663.86 1664.08 1664.32</code></pre>
</div>
<div id="sec:reporterions" class="section level2">
<h2 class="hasAnchor">
<a href="#sec:reporterions" class="anchor"></a>Reporter ions</h2>
<p>Reporter ions are defined with the <em>ReporterIons</em> class. Specific peaks of interest are defined by a MZ value, a with around the expected MZ and a name (and optionally a colour for plotting, see section @ref(sec:plotting)). <em>ReporterIons</em> instances are required to quantify reporter peaks in <em>MSnExp</em> experiments. Instances for the most commonly used isobaric tags like iTRAQ 4-plex and 8-plex and TMT 6- and 10-plex tags are already defined in <em><a href="http://bioconductor.org/packages/MSnbase">MSnbase</a></em>. See <code><a href="../reference/ReporterIons-class.html">?ReporterIons</a></code> for details about how to generate new <em>ReporterIons</em> objects.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">iTRAQ4</code></pre></div>
<pre><code>## Object of class "ReporterIons"
## iTRAQ4: '4-plex iTRAQ' with 4 reporter ions
##  - 114.1112 +/- 0.05 (red)
##  - 115.1083 +/- 0.05 (green)
##  - 116.1116 +/- 0.05 (blue)
##  - 117.115 +/- 0.05 (yellow)</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">TMT10</code></pre></div>
<pre><code>## Object of class "ReporterIons"
## TMT10HCD: '10-plex TMT HCD' with 10 reporter ions
##  - 126.1277 +/- 0.002 (#8DD3C7)
##  - 127.1248 +/- 0.002 (#FFFFB3)
##  - 127.1311 +/- 0.002 (#BEBADA)
##  - 128.1281 +/- 0.002 (#FB8072)
##  - 128.1344 +/- 0.002 (#80B1D3)
##  - 129.1315 +/- 0.002 (#FDB462)
##  - 129.1378 +/- 0.002 (#B3DE69)
##  - 130.1348 +/- 0.002 (#FCCDE5)
##  - 130.1411 +/- 0.002 (#D9D9D9)
##  - 131.1382 +/- 0.002 (#BC80BD)</code></pre>
</div>
<div id="sec:chromatograms" class="section level2">
<h2 class="hasAnchor">
<a href="#sec:chromatograms" class="anchor"></a>Chromatogram objects</h2>
<p>Chromatographic data, i.e. intensity values along the retention time dimension for a given <span class="math inline">\(m/z\)</span> range/slice, can be extracted with the <code>chromatogram</code> method. Below we read a file from the <code>msdata</code> package and extract the (MS level 1) chromatogram. Without providing an <span class="math inline">\(m/z\)</span> and a retention time range the function returns the total ion chromatogram (TIC) for each file within the <code>MSnExp</code> or <code>OnDiskMSnExp</code> object. See also section @ref(sec:io3) for importing chromatographic data from SRM/MRM experiments.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">f &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">system.file</span>(<span class="st">"microtofq/MM14.mzML"</span>, <span class="dt">package =</span> <span class="st">"msdata"</span>))
mtof &lt;-<span class="st"> </span><span class="kw"><a href="../reference/readMSData.html">readMSData</a></span>(f, <span class="dt">mode =</span> <span class="st">"onDisk"</span>)</code></pre></div>
<pre><code>## Warning: pwiz not yet initialized.</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mtof_tic &lt;-<span class="st"> </span><span class="kw"><a href="../reference/chromatogram-MSnExp-method.html">chromatogram</a></span>(mtof)
mtof_tic</code></pre></div>
<pre><code>## Chromatograms with 1 row and 1 column
##           MM14.mzML
##      &lt;Chromatogram&gt;
## [1,]    length: 112
## phenoData with 1 variables
## featureData with 1 variables</code></pre>
<p>Chromatographic data, represented by the intensity-retention time duplets, is stored in the <code>Chromatogram</code> object. The <code>chromatogram</code> method returns a <code>Chromatograms</code> object (note the <em>s</em>) which holds multiple <code>Chromatogram</code> objects and arranges them in a two-dimensional grid with columns representing files/samples of the <code>MSnExp</code> or <code>OnDiskMSnExp</code> object and rows <span class="math inline">\(m/z\)</span>-retention time ranges. In the example above the <code>Chromatograms</code> object contains only a single <code>Chromatogram</code> object. Below we access this chromatogram object. Similar to the <code>Spectrum</code> objects, <code>Chromatogram</code> objects provide the accessor functions <code>intensity</code> and <code>rtime</code> to access the data, as well as the <code>mz</code> function, that returns the <span class="math inline">\(m/z\)</span> range of the chromatogram.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mtof_tic[<span class="dv">1</span>, <span class="dv">1</span>]</code></pre></div>
<pre><code>## Object of class: Chromatogram
## Intensity values aggregated using: sum 
## length of object: 112
## from file: 1
## mz range: [94.80679, 1004.962]
## rt range: [270.334, 307.678]
## MS level: 1</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(<span class="kw"><a href="../reference/Spectrum-class.html">intensity</a></span>(mtof_tic[<span class="dv">1</span>, <span class="dv">1</span>]))</code></pre></div>
<pre><code>## F1.S001 F1.S002 F1.S003 F1.S004 F1.S005 F1.S006 
##   64989   67445   77843  105097  155609  212760</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(<span class="kw"><a href="../reference/Spectrum-class.html">rtime</a></span>(mtof_tic[<span class="dv">1</span>, <span class="dv">1</span>]))</code></pre></div>
<pre><code>## F1.S001 F1.S002 F1.S003 F1.S004 F1.S005 F1.S006 
## 270.334 270.671 271.007 271.343 271.680 272.016</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/Spectrum-class.html">mz</a></span>(mtof_tic[<span class="dv">1</span>, <span class="dv">1</span>])</code></pre></div>
<pre><code>## [1]   94.80679 1004.96155</code></pre>
<p>To extract the base peak chromatogram (the largest peak along the <span class="math inline">\(m/z\)</span> dimension for each retention time/spectrum) we set the <code>aggregationFun</code> argument to <code>"max"</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mtof_bpc &lt;-<span class="st"> </span><span class="kw"><a href="../reference/chromatogram-MSnExp-method.html">chromatogram</a></span>(mtof, <span class="dt">aggregationFun =</span> <span class="st">"max"</span>)</code></pre></div>
<p>See the <code>Chromatogram</code> help page and the vignettes from the <em><a href="http://bioconductor.org/packages/xcms">xcms</a></em> package for more details and use cases, also on how to extract chromatograms for specific ions.</p>
</div>
</div>
<div id="sec:plotting" class="section level1">
<h1 class="hasAnchor">
<a href="#sec:plotting" class="anchor"></a>Plotting raw data</h1>
<div id="sec:msmaps" class="section level2">
<h2 class="hasAnchor">
<a href="#sec:msmaps" class="anchor"></a>MS data space</h2>
<p>The <em>MSmap</em> class can be used to isolate specific slices of interest from a complete MS acquisition by specifying <span class="math inline">\(m/z\)</span> and retention time ranges. One needs a raw data file in a format supported by <em><a href="http://bioconductor.org/packages/mzR">mzR</a></em>’s <code>openMSfile</code> (<code>mzML</code>, <code>mzXML</code>, …). Below we first download a raw data file from the PRIDE repository and create an <em>MSmap</em> containing all the MS1 spectra between acquired between 30 and 35 minutes and peaks between 521 and 523 <span class="math inline">\(m/z\)</span>. See <code><a href="../reference/MSmap-class.html">?MSmap</a></code> for details.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## downloads the data
<span class="kw">library</span>(<span class="st">"rpx"</span>)
px1 &lt;-<span class="st"> </span><span class="kw"><a href="http://www.rdocumentation.org/packages/rpx/topics/PXDataset-class">PXDataset</a></span>(<span class="st">"PXD000001"</span>)
mzf &lt;-<span class="st"> </span><span class="kw"><a href="http://www.rdocumentation.org/packages/rpx/topics/PXDataset-class">pxget</a></span>(px1, <span class="dv">7</span>)
     
## reads the data 
ms &lt;-<span class="st"> </span><span class="kw">openMSfile</span>(mzf)
hd &lt;-<span class="st"> </span><span class="kw"><a href="../reference/pSet-class.html">header</a></span>(ms)
     
## a set of spectra of interest: MS1 spectra eluted
## between 30 and 35 minutes retention time
ms1 &lt;-<span class="st"> </span><span class="kw">which</span>(hd<span class="op">$</span>msLevel <span class="op">==</span><span class="st"> </span><span class="dv">1</span>)
rtsel &lt;-<span class="st"> </span>hd<span class="op">$</span>retentionTime[ms1] <span class="op">/</span><span class="st"> </span><span class="dv">60</span> <span class="op">&gt;</span><span class="st"> </span><span class="dv">30</span> <span class="op">&amp;</span>
<span class="st">    </span>hd<span class="op">$</span>retentionTime[ms1] <span class="op">/</span><span class="st"> </span><span class="dv">60</span> <span class="op">&lt;</span><span class="st"> </span><span class="dv">35</span>
     
## the map
M &lt;-<span class="st"> </span><span class="kw"><a href="../reference/MSmap-class.html">MSmap</a></span>(ms, ms1[rtsel], <span class="dv">521</span>, <span class="dv">523</span>, .<span class="dv">005</span>, hd, <span class="dt">zeroIsNA =</span> <span class="ot">TRUE</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">M</code></pre></div>
<pre><code>## Object of class "MSmap"
##  Map [75, 401]
##   [1]  Retention time: 30:1 - 34:58 
##   [2]  M/Z: 521 - 523 (res 0.005)</code></pre>
<p>The <code>M</code> map object can be rendered as a heatmap with <code>plot</code>, as shown on figure @ref(fig:mapheat).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/plot-methods.html">plot</a></span>(M, <span class="dt">aspect =</span> <span class="dv">1</span>, <span class="dt">allTicks =</span> <span class="ot">FALSE</span>)</code></pre></div>
<div class="figure">
<img src="MSnbase-demo_files/figure-html/mapheat-1.png" alt="Heat map of a chunk of the MS data." width="700"><p class="caption">
Heat map of a chunk of the MS data.
</p>
</div>
<p>One can also render the data in 3 dimension with the <code>plot3D</code> function, as show on figure @ref(fig:map3d).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/MSmap-class.html">plot3D</a></span>(M)</code></pre></div>
<div class="figure">
<img src="MSnbase-demo_files/figure-html/map3d-1.png" alt="3 dimensional represention of MS map data." width="700"><p class="caption">
3 dimensional represention of MS map data.
</p>
</div>
<p>To produce figure @ref(fig:map3d2), we create a second <em>MSmap</em> object containing the first two MS1 spectra of the first map (object <code>M</code> above) and all intermediate MS2 spectra and display <span class="math inline">\(m/z\)</span> values between 100 and 1000.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">i &lt;-<span class="st"> </span>ms1[<span class="kw">which</span>(rtsel)][<span class="dv">1</span>]
j &lt;-<span class="st"> </span>ms1[<span class="kw">which</span>(rtsel)][<span class="dv">2</span>]
M2 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/MSmap-class.html">MSmap</a></span>(ms, i<span class="op">:</span>j, <span class="dv">100</span>, <span class="dv">1000</span>, <span class="dv">1</span>, hd)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">M2</code></pre></div>
<pre><code>## Object of class "MSmap"
##  Map [12, 901]
##   [1]  Retention time: 30:1 - 30:5 
##   [2]  M/Z: 100 - 1000 (res 1)</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/MSmap-class.html">plot3D</a></span>(M2)</code></pre></div>
<div class="figure">
<img src="MSnbase-demo_files/figure-html/map3d2-1.png" alt="3 dimensional represention of MS map data. MS1 and MS2 spectra are coloured in blue and magenta respectively." width="700"><p class="caption">
3 dimensional represention of MS map data. MS1 and MS2 spectra are coloured in blue and magenta respectively.
</p>
</div>
</div>
<div id="sec:specplots" class="section level2">
<h2 class="hasAnchor">
<a href="#sec:specplots" class="anchor"></a>MS Spectra</h2>
<p>Spectra can be plotted individually or as part of (subset) experiments with the <code>plot</code> method. Full spectra can be plotted (using <code>full=TRUE</code>), specific reporter ions of interest (by specifying with reporters with <code>reporters=iTRAQ4</code> for instance) or both (see figure @ref(fig:spectrumPlot)).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/plot-methods.html">plot</a></span>(sp, <span class="dt">reporters =</span> iTRAQ4, <span class="dt">full =</span> <span class="ot">TRUE</span>)</code></pre></div>
<div class="figure">
<img src="MSnbase-demo_files/figure-html/spectrumPlot-1.png" alt="Raw MS2 spectrum with details about reporter ions." width="700"><p class="caption">
Raw MS2 spectrum with details about reporter ions.
</p>
</div>
<p>It is also possible to plot all spectra of an experiment (figure @ref(fig:msnexpPlot)). Lets start by subsetting the <code>itraqdata</code> experiment using the protein accession numbers included in the feature metadata, and keep the 6 from the <em>BSA</em> protein.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sel &lt;-<span class="st"> </span><span class="kw">fData</span>(itraqdata)<span class="op">$</span>ProteinAccession <span class="op">==</span><span class="st"> "BSA"</span>
bsa &lt;-<span class="st"> </span>itraqdata[sel]
bsa</code></pre></div>
<pre><code>## MSn experiment data ("MSnExp")
## Object size in memory: 0.11 Mb
## - - - Spectra data - - -
##  MS level(s): 2 
##  Number of spectra: 3 
##  MSn retention times: 19:9 - 36:17 minutes
## - - - Processing information - - -
## Data loaded: Wed May 11 18:54:39 2011 
## Updated from version 0.3.0 to 0.3.1 [Fri Jul  8 20:23:25 2016] 
## Data [logically] subsetted 3 spectra: Thu May 17 15:35:35 2018 
##  MSnbase version: 1.1.22 
## - - - Meta data  - - -
## phenoData
##   rowNames: 1
##   varLabels: sampleNames sampleNumbers
##   varMetadata: labelDescription
## Loaded from:
##   dummyiTRAQ.mzXML 
## protocolData: none
## featureData
##   featureNames: X1 X52 X53
##   fvarLabels: spectrum ProteinAccession ProteinDescription
##     PeptideSequence
##   fvarMetadata: labelDescription
## experimentData: use 'experimentData(object)'</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">as.character</span>(<span class="kw">fData</span>(bsa)<span class="op">$</span>ProteinAccession)</code></pre></div>
<pre><code>## [1] "BSA" "BSA" "BSA"</code></pre>
<p>These can then be visualised together by plotting the <em>MSnExp</em> object, as illustrated on figure @ref(fig:msnexpPlot).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/plot-methods.html">plot</a></span>(bsa, <span class="dt">reporters =</span> iTRAQ4, <span class="dt">full =</span> <span class="ot">FALSE</span>) <span class="op">+</span><span class="st"> </span><span class="kw">theme_gray</span>(<span class="dv">8</span>)</code></pre></div>
<div class="figure">
<img src="MSnbase-demo_files/figure-html/msnexpPlot-1.png" alt="Experiment-wide raw MS2 spectra. The y-axes of the individual spectra are automatically rescaled to the same range. See section \@ref(sec:norm) to rescale peaks identically." width="700"><p class="caption">
Experiment-wide raw MS2 spectra. The y-axes of the individual spectra are automatically rescaled to the same range. See section @ref(sec:norm) to rescale peaks identically.
</p>
</div>
<pre><code>## NULL</code></pre>
<p><strong>Customising your plots</strong> The <em><a href="http://bioconductor.org/packages/MSnbase">MSnbase</a></em> <code>plot</code> methods have a logical <code>plot</code> parameter (default is <code>TRUE</code>), that specifies if the plot should be printed to the current device. A plot object is also (invisibly) returned, so that it can be saved as a variable for later use or for customisation.</p>
<p><em><a href="http://bioconductor.org/packages/MSnbase">MSnbase</a></em> uses the  package to generate plots, which can subsequently easily be customised. More details about  can be found in <span class="citation">(Wickham 2009)</span> (especially chapter 8) and on <a href="http://had.co.nz/ggplot2/" class="uri">http://had.co.nz/ggplot2/</a>. Finally, if a plot object has been saved in a variable <code>p</code>, it is possible to obtain a summary of the object with <code>summary(p)</code>. To view the data frame used to generate the plot, use <code>p$data</code>.</p>
</div>
<div id="sec:chromplots" class="section level2">
<h2 class="hasAnchor">
<a href="#sec:chromplots" class="anchor"></a>MS Chromatogram</h2>
<p>Chromatographic data can be plotted using the <code>plot</code> method which, in contrast to the <code>plot</code> method for <code>Spectrum</code> classes, uses R base graphics. The <code>plot</code> method is implemented for <code>Chromatogram</code> and <code>Chromatograms</code> classes. The latter plots all chromatograms for the same <span class="math inline">\(m/z\)</span>-rt range of all files in an experiment (i.e. for one row in the <code>Chromatograms</code> object) into one plot.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/plot-methods.html">plot</a></span>(mtof_bpc)</code></pre></div>
<div class="figure">
<img src="MSnbase-demo_files/figure-html/chromPlot-1.png" alt="Base peak chromatogram." width="700"><p class="caption">
Base peak chromatogram.
</p>
</div>
</div>
</div>
<div id="sec:id" class="section level1">
<h1 class="hasAnchor">
<a href="#sec:id" class="anchor"></a>Tandem MS identification data</h1>
<p>Typically, identification data is produced by a search engine and serialised to disk in the <code>mzIdentML</code> (or <code>mzid</code>) file format. This format can be parsed by <code>openIDfile</code> from the <em><a href="http://bioconductor.org/packages/mzR">mzR</a></em> package or <code>mzID</code> from the <em><a href="http://bioconductor.org/packages/mzID">mzID</a></em> package. The <code>MSnbase</code> package relies on the former (which is faster) and offers a simplified interface by converting the dedicated identification data objects into <code>data.frames</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(<span class="st">"msdata"</span>)
f &lt;-<span class="st"> "TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzid"</span>
idf &lt;-<span class="st"> </span>msdata<span class="op">::</span><span class="kw"><a href="http://www.rdocumentation.org/packages/msdata/topics/proteomics">ident</a></span>(<span class="dt">full.names =</span> <span class="ot">TRUE</span>, <span class="dt">pattern =</span> f)
iddf &lt;-<span class="st"> </span><span class="kw"><a href="../reference/readMzIdData.html">readMzIdData</a></span>(idf)
<span class="kw">str</span>(iddf)</code></pre></div>
<pre><code>## 'data.frame':    5802 obs. of  32 variables:
##  $ sequence                : chr  "RQCRTDFLNYLR" "ESVALADQVTCVDWRNRKATKK" "KELLCLAMQIIR" "QRMARTSDKQQSIRFLERLCGR" ...
##  $ spectrumID              : chr  "controllerType=0 controllerNumber=1 scan=2949" "controllerType=0 controllerNumber=1 scan=6534" "controllerType=0 controllerNumber=1 scan=5674" "controllerType=0 controllerNumber=1 scan=4782" ...
##  $ chargeState             : int  3 2 2 3 3 3 2 3 3 2 ...
##  $ rank                    : int  1 1 1 1 1 1 1 1 1 1 ...
##  $ passThreshold           : logi  TRUE TRUE TRUE TRUE TRUE TRUE ...
##  $ experimentalMassToCharge: num  548 1288 744 913 927 ...
##  $ calculatedMassToCharge  : num  548 1288 744 913 926 ...
##  $ modNum                  : int  1 1 1 1 1 1 1 2 2 1 ...
##  $ isDecoy                 : logi  FALSE FALSE TRUE FALSE TRUE FALSE ...
##  $ post                    : chr  "V" "G" "Q" "D" ...
##  $ pre                     : chr  "R" "R" "R" "R" ...
##  $ start                   : int  574 69 131 182 135 310 182 201 201 121 ...
##  $ end                     : int  585 90 142 203 158 334 203 233 233 140 ...
##  $ DatabaseAccess          : chr  "ECA2006" "ECA1676" "XXX_ECA2855" "ECA3009" ...
##  $ DBseqLength             : int  1295 110 157 437 501 477 437 1204 1204 210 ...
##  $ DatabaseSeq             : chr  "" "" "" "" ...
##  $ DatabaseDescription     : chr  "ECA2006 ATP-dependent helicase" "ECA1676 putative growth inhibitory protein" "" "ECA3009 putative coproporphyrinogen oxidase" ...
##  $ acquisitionNum          : num  2949 6534 5674 4782 5839 ...
##  $ spectrumFile            : chr  "TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzML" "TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzML" "TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzML" "TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzML" ...
##  $ idFile                  : chr  "TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzid" "TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzid" "TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzid" "TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzid" ...
##  $ MS.GF.RawScore          : num  10 12 8 -5 8 7 21 -31 -31 -3 ...
##  $ MS.GF.DeNovoScore       : num  101 121 74 160 241 214 196 165 165 59 ...
##  $ MS.GF.SpecEValue        : num  4.62e-08 7.26e-08 9.34e-08 1.27e-07 1.32e-07 ...
##  $ MS.GF.EValue            : num  0.132 0.209 0.267 0.366 0.379 ...
##  $ MS.GF.QValue            : num  0.525 0.61 0.625 0.717 0.736 ...
##  $ MS.GF.PepQValue         : num  0.549 0.623 0.636 0.724 0.745 ...
##  $ modName                 : chr  "Carbamidomethyl" "Carbamidomethyl" "Carbamidomethyl" "Carbamidomethyl" ...
##  $ modMass                 : num  57 57 57 57 57 ...
##  $ modLocation             : int  3 11 5 20 20 21 20 1 28 4 ...
##  $ subOriginalResidue      : chr  NA NA NA NA ...
##  $ subReplacementResidue   : chr  NA NA NA NA ...
##  $ subLocation             : int  NA NA NA NA NA NA NA NA NA NA ...</code></pre>
<p>The spectra along the rows are duplicated when the PSM can be assigned to multiple proteins, such as</p>
<pre><code>##                                         spectrumID    sequence
## 3794 controllerType=0 controllerNumber=1 scan=5291  RKAYLLRMRR
## 4886 controllerType=0 controllerNumber=1 scan=5291 ILLHPLRTLMR
##      DatabaseAccess
## 3794    XXX_ECA2052
## 4886        ECA1281</code></pre>
<p>of when there are multiple modifications in a PSM, such as</p>
<pre><code>##                                        spectrumID
## 411 controllerType=0 controllerNumber=1 scan=4936
## 412 controllerType=0 controllerNumber=1 scan=4936
##                                    sequence         modName modLocation
## 411 ICSAILRIISPEWWGRKLWRLRCEWRENQFRAIGVIHKK Carbamidomethyl           2
## 412 ICSAILRIISPEWWGRKLWRLRCEWRENQFRAIGVIHKK Carbamidomethyl          23</code></pre>
<p>At this stage, it is useful to perform some exploratory data analysis and visualisation on the identification data. For example</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">table</span>(iddf<span class="op">$</span>isDecoy)</code></pre></div>
<pre><code>## 
## FALSE  TRUE 
##  2906  2896</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">table</span>(iddf<span class="op">$</span>chargeState)</code></pre></div>
<pre><code>## 
##    2    3    4    5    6 
## 3312 2064  400   23    3</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(<span class="st">"ggplot2"</span>)
<span class="kw"><a href="http://www.rdocumentation.org/packages/ggplot2/topics/ggplot">ggplot</a></span>(<span class="dt">data =</span> iddf, <span class="kw"><a href="http://www.rdocumentation.org/packages/ggplot2/topics/aes">aes</a></span>(<span class="dt">x =</span> MS.GF.RawScore, <span class="dt">colour =</span> isDecoy)) <span class="op">+</span>
<span class="st">    </span><span class="kw"><a href="http://www.rdocumentation.org/packages/ggplot2/topics/geom_density">geom_density</a></span>() <span class="op">+</span>
<span class="st">    </span><span class="kw"><a href="http://www.rdocumentation.org/packages/ggplot2/topics/facet_wrap">facet_wrap</a></span>(<span class="op">~</span>chargeState)</code></pre></div>
<p><img src="MSnbase-demo_files/figure-html/idvis-1.png" width="700"></p>
<p>The <code>filterIdentificationDataFrame</code> function can be used to remove - PSMs that match decoy entries - PSMs of rank &gt; 1 - PSMs that match non-proteotypic proteins</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">iddf &lt;-<span class="st"> </span><span class="kw"><a href="../reference/filterIdentificationDataFrame.html">filterIdentificationDataFrame</a></span>(iddf)</code></pre></div>
<p>This <code>data.frame</code> can be now be further reduced so that individual rows represent unique spectra, which can be done with the <code>reduce</code> method.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">iddf2 &lt;-<span class="st"> </span><span class="kw">reduce</span>(iddf, <span class="dt">key =</span> <span class="st">"spectrumID"</span>)</code></pre></div>
<p>This reduces the number of rows from 2710 to 2646.</p>
<p>The first duplicated spectrum mentioned above is now unique as is matched a decoy protein that was filtered out with <code>filterIdentificationDataFrame</code>.</p>
<pre><code>##                                         spectrumID    sequence
## 1808 controllerType=0 controllerNumber=1 scan=5291 ILLHPLRTLMR
##      DatabaseAccess
## 1808        ECA1281</code></pre>
<p>The matches to multiple modification in the same peptide are now combined into a single row and documented as semicolon-separated values.</p>
<pre><code>##                                         spectrumID
## 1659 controllerType=0 controllerNumber=1 scan=4936
##                                                                             sequence
## 1659 ICSAILRIISPEWWGRKLWRLRCEWRENQFRAIGVIHKK;ICSAILRIISPEWWGRKLWRLRCEWRENQFRAIGVIHKK
##                              modName modLocation
## 1659 Carbamidomethyl;Carbamidomethyl        2;23</code></pre>
<p>This is the form that is used when combined to raw data, as described in the next section.</p>
<div id="adding-identification-data" class="section level2">
<h2 class="hasAnchor">
<a href="#adding-identification-data" class="anchor"></a>Adding identification data</h2>
<p><em><a href="http://bioconductor.org/packages/MSnbase">MSnbase</a></em> is able to integrate identification data from <code>mzIdentML</code> <span class="citation">(Jones et al. 2012)</span> files.</p>
<p>We first load two example files shipped with the <em><a href="http://bioconductor.org/packages/MSnbase">MSnbase</a></em> containing raw data (as above) and the corresponding identification results respectively. The raw data is read with the <code>readMSData</code>, as demonstrated above. As can be seen, the default feature data only contain spectra numbers. More data about the spectra is of course available in an <em>MSnExp</em> object, as illustrated in the previous sections. See also <code><a href="../reference/pSet-class.html">?pSet</a></code> and <code><a href="../reference/MSnExp-class.html">?MSnExp</a></code> for more details.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## find path to a mzXML file
quantFile &lt;-<span class="st"> </span><span class="kw">dir</span>(<span class="kw">system.file</span>(<span class="dt">package =</span> <span class="st">"MSnbase"</span>, <span class="dt">dir =</span> <span class="st">"extdata"</span>),
                 <span class="dt">full.name =</span> <span class="ot">TRUE</span>, <span class="dt">pattern =</span> <span class="st">"mzXML$"</span>)
## find path to a mzIdentML file
identFile &lt;-<span class="st"> </span><span class="kw">dir</span>(<span class="kw">system.file</span>(<span class="dt">package =</span> <span class="st">"MSnbase"</span>, <span class="dt">dir =</span> <span class="st">"extdata"</span>),
                 <span class="dt">full.name =</span> <span class="ot">TRUE</span>, <span class="dt">pattern =</span> <span class="st">"dummyiTRAQ.mzid"</span>)
## create basic MSnExp
msexp &lt;-<span class="st"> </span><span class="kw"><a href="../reference/readMSData.html">readMSData</a></span>(quantFile, <span class="dt">verbose =</span> <span class="ot">FALSE</span>)</code></pre></div>
<pre><code>## Warning: The direct support for chromatogram info is only available in mzML
## format.</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(<span class="kw">fData</span>(msexp), <span class="dt">n =</span> <span class="dv">2</span>)</code></pre></div>
<pre><code>##       spectrum
## F1.S1        1
## F1.S2        2</code></pre>
<p>The <code>addIdentificationData</code> method takes an <em>MSnExp</em> instance (or an <em>MSnSet</em> instance storing quantitation data, see section @ref(sec:quant)) as first argument and one or multiple <code>mzIdentML</code> file names (as a character vector) as second one<a href="#fn6" class="footnoteRef" id="fnref6"><sup>6</sup></a> and updates the <em>MSnExp</em> feature data using the identification data read from the <code>mzIdentML</code> file(s).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">msexp &lt;-<span class="st"> </span><span class="kw"><a href="../reference/addIdentificationData-methods.html">addIdentificationData</a></span>(msexp, <span class="dt">id =</span> identFile)
<span class="kw">head</span>(<span class="kw">fData</span>(msexp), <span class="dt">n =</span> <span class="dv">2</span>)</code></pre></div>
<pre><code>##       spectrum acquisition.number          sequence chargeState rank
## F1.S1        1                  1 VESITARHGEVLQLRPK           3    1
## F1.S2        2                  2     IDGQWVTHQWLKK           3    1
##       passThreshold experimentalMassToCharge calculatedMassToCharge modNum
## F1.S1          TRUE                 645.3741               645.0375      0
## F1.S2          TRUE                 546.9586               546.9633      0
##       isDecoy post pre start end DatabaseAccess DBseqLength DatabaseSeq
## F1.S1   FALSE    A   R   170 186        ECA0984         231            
## F1.S2   FALSE    A   K    50  62        ECA1028         275            
##                                                              DatabaseDescription
## F1.S1                                        ECA0984 DNA mismatch repair protein
## F1.S2 ECA1028 2,3,4,5-tetrahydropyridine-2,6-dicarboxylate N-succinyltransferase
##                idFile MS.GF.RawScore MS.GF.DeNovoScore MS.GF.SpecEValue
## F1.S1 dummyiTRAQ.mzid            -39                77     5.527468e-05
## F1.S2 dummyiTRAQ.mzid            -30                39     9.399048e-06
##       MS.GF.EValue modName modMass modLocation subOriginalResidue
## F1.S1     79.36958    &lt;NA&gt;      NA          NA               &lt;NA&gt;
## F1.S2     13.46615    &lt;NA&gt;      NA          NA               &lt;NA&gt;
##       subReplacementResidue subLocation nprot npep.prot npsm.prot npsm.pep
## F1.S1                  &lt;NA&gt;          NA     1         1         1        1
## F1.S2                  &lt;NA&gt;          NA     1         1         1        1</code></pre>
<p>Finally we can use <code>idSummary</code> to summarise the percentage of identified features per quantitation/identification pairs.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/MSnSet-class.html">idSummary</a></span>(msexp)</code></pre></div>
<pre><code>##       spectrumFile          idFile coverage
## 1 dummyiTRAQ.mzXML dummyiTRAQ.mzid      0.6</code></pre>
<p>When identification data is present, and hence peptide sequences, one can annotation fragment peaks on the MS2 figure by passing the peptide sequence to the <code>plot</code> method.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">itraqdata2 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/pickPeaks-method.html">pickPeaks</a></span>(itraqdata, <span class="dt">verbose=</span><span class="ot">FALSE</span>)
i &lt;-<span class="st"> </span><span class="dv">14</span>
s &lt;-<span class="st"> </span><span class="kw">as.character</span>(<span class="kw">fData</span>(itraqdata2)[i, <span class="st">"PeptideSequence"</span>])</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/plot-methods.html">plot</a></span>(itraqdata2[[i]], s, <span class="dt">main =</span> s)</code></pre></div>
<div class="figure">
<img src="MSnbase-demo_files/figure-html/fragplot-1.png" alt="Annotated MS2 spectrum." width="700"><p class="caption">
Annotated MS2 spectrum.
</p>
</div>
<p>The fragment ions are calculated with the <code>calculateFragments</code>, described in section @ref(sec:calcfrag).</p>
</div>
<div id="filtering-identification-data" class="section level2">
<h2 class="hasAnchor">
<a href="#filtering-identification-data" class="anchor"></a>Filtering identification data</h2>
<p>One can remove the features that have not been identified using <code>removeNoId</code>. This function uses by default the <code>pepseq</code> feature variable to search the presence of missing data (<code>NA</code> values) and then filter these non-identified spectra.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">fData</span>(msexp)<span class="op">$</span>sequence</code></pre></div>
<pre><code>## [1] "VESITARHGEVLQLRPK" "IDGQWVTHQWLKK"     NA                 
## [4] NA                  "LVILLFR"</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">msexp &lt;-<span class="st"> </span><span class="kw"><a href="../reference/removeNoId-methods.html">removeNoId</a></span>(msexp)
<span class="kw">fData</span>(msexp)<span class="op">$</span>sequence</code></pre></div>
<pre><code>## [1] "VESITARHGEVLQLRPK" "IDGQWVTHQWLKK"     "LVILLFR"</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/MSnSet-class.html">idSummary</a></span>(msexp)</code></pre></div>
<pre><code>##       spectrumFile          idFile coverage
## 1 dummyiTRAQ.mzXML dummyiTRAQ.mzid        1</code></pre>
<p>Similarly, the <code>removeMultipleAssignment</code> method can be used to filter out non-unique features, i.e. that have been assigned to protein groups with more than one member. This function uses by default the <code>nprot</code> feature variable.</p>
<p>Note that <code>removeNoId</code> and <code>removeMultipleAssignment</code> methods can also be called on <em>MSnExp</em> instances.</p>
</div>
<div id="sec:calcfrag" class="section level2">
<h2 class="hasAnchor">
<a href="#sec:calcfrag" class="anchor"></a>Calculate Fragments</h2>
<p><em><a href="http://bioconductor.org/packages/MSnbase">MSnbase</a></em> is able to calculate theoretical peptide fragments via <code>calculateFragments</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/calculateFragments-methods.html">calculateFragments</a></span>(<span class="st">"ACEK"</span>,
                   <span class="dt">type =</span> <span class="kw">c</span>(<span class="st">"a"</span>, <span class="st">"b"</span>, <span class="st">"c"</span>, <span class="st">"x"</span>, <span class="st">"y"</span>, <span class="st">"z"</span>))</code></pre></div>
<pre><code>##           mz ion type pos z seq
## 1   44.04947  a1    a   1 1   A
## 2  204.08012  a2    a   2 1  AC
## 3  333.12271  a3    a   3 1 ACE
## 4   72.04439  b1    b   1 1   A
## 5  232.07504  b2    b   2 1  AC
## 6  361.11763  b3    b   3 1 ACE
## 7   89.07094  c1    c   1 1   A
## 8  249.10159  c2    c   2 1  AC
## 9  378.14417  c3    c   3 1 ACE
## 10 173.09207  x1    x   1 1   K
## 11 302.13466  x2    x   2 1  EK
## 12 462.16531  x3    x   3 1 CEK
## 13 147.11280  y1    y   1 1   K
## 14 276.15539  y2    y   2 1  EK
## 15 436.18604  y3    y   3 1 CEK
## 16 130.08625  z1    z   1 1   K
## 17 259.12884  z2    z   2 1  EK
## 18 419.15949  z3    z   3 1 CEK
## 19 269.13700 x2_   x_   2 1  EK
## 20 243.15774 y2_   y_   2 1  EK
## 21 226.13119 z2_   z_   2 1  EK
## 22 140.09441 x1_   x_   1 1   K
## 23 429.16765 x3_   x_   3 1 CEK
## 24 114.11515 y1_   y_   1 1   K
## 25 403.18839 y3_   y_   3 1 CEK
## 26  97.08860 z1_   z_   1 1   K
## 27 386.16184 z3_   z_   3 1 CEK</code></pre>
<p>It is also possible to match these fragments against an <em>Spectrum2</em> object.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">pepseq &lt;-<span class="st"> </span><span class="kw">fData</span>(msexp)<span class="op">$</span>sequence[<span class="dv">1</span>]
<span class="kw"><a href="../reference/calculateFragments-methods.html">calculateFragments</a></span>(pepseq, msexp[[<span class="dv">1</span>]], <span class="dt">type=</span><span class="kw">c</span>(<span class="st">"b"</span>, <span class="st">"y"</span>))</code></pre></div>
<pre><code>##           mz  intensity  ion type pos z             seq       error
## 1   100.0005       0.00   b1    b   1 1               V  0.07522824
## 2   114.1109  706555.69  y1_   y_   1 1               K  0.00425275
## 3   429.2563 1972344.00   b4    b   4 1            VESI -0.02189010
## 4   513.3047 2574137.00   y4    y   4 1            LRPK  0.04598246
## 5   754.4504  537234.81   y6    y   6 1          LQLRPK  0.04293155
## 6   836.6139   82364.42  y7*   y*   7 1         VLQLRPK -0.07865960
## 7   982.5354  500159.06   y8    y   8 1        EVLQLRPK  0.06897061
## 8  1080.5867  209363.69  b10    b  10 1      VESITARHGE -0.04344392
## 9  1656.9252       0.00 b15_   b_  15 1 VESITARHGEVLQLR  0.01662010
## 10 1672.8380   76075.02 b15*   b*  15 1 VESITARHGEVLQLR  0.07488430
## 11 1688.0375  136748.83 y15*   y*  15 1 SITARHGEVLQLRPK -0.07729359</code></pre>
</div>
</div>
<div id="sec:qc" class="section level1">
<h1 class="hasAnchor">
<a href="#sec:qc" class="anchor"></a>Quality control</h1>
<p>The current section is not executed dynamically for package size and processing time constrains. The figures and tables have been generated with the respective methods and included statically in the vignette for illustration purposes.</p>
<p><em><a href="http://bioconductor.org/packages/MSnbase">MSnbase</a></em> allows easy and flexible access to the data, which allows to visualise data features to assess it’s quality. Some methods are readily available, although many QC approaches will be experiment specific and users are encourage to explore their data.</p>
<p>The <code>plot2d</code> method takes one <em>MSnExp</em> instance as first argument to produce retention time <em>vs.</em> precursor MZ scatter plots. Points represent individual MS2 spectra and can be coloured based on precursor charge (with second argument <code>z="charge"</code>), total ion count (<code>z="ionCount"</code>), number of peaks in the MS2 spectra <code>z="peaks.count"</code>) or, when multiple data files were loaded, file <code>z="file"</code>), as illustrated on the <a href="#fig:plot2d">next figure</a>. The lower right panel is produced for only a subset of proteins. See the method documentation for more details.</p>
<div class="figure">
<img src="Figures/plot2d-figure.png" alt="Illustration of the plot2d output." id="fig:plot2d"><p class="caption">Illustration of the <code>plot2d</code> output.</p>
</div>
<p>The <code>plotDensity</code> method illustrates the distribution of several parameters of interest (see <a href="#fig:plotDensity">figure below</a>). Similarly to <code>plot2d</code>, the first argument is an <em>MSnExp</em> instance. The second is one of <code>precursor.mz</code>, <code>peaks.count</code> or <code>ionCount</code>, whose density will be plotted. An optional third argument specifies whether the x axes should be logged.</p>
<div class="figure">
<img src="Figures/plotDensity-figure.png" alt="Illustration of the plotDensity output." id="fig:plotDensity"><p class="caption">Illustration of the <code>plotDensity</code> output.</p>
</div>
<p>The <code>plotMzDelta</code> method<a href="#fn7" class="footnoteRef" id="fnref7"><sup>7</sup></a> implements the <span class="math inline">\(m/z\)</span> delta plot from <span class="citation">(Foster et al. 2011)</span> The <span class="math inline">\(m/z\)</span> delta plot illustrates the suitability of MS2 spectra for identification by plotting the <span class="math inline">\(m/z\)</span> differences of the most intense peaks. The resulting histogram should optimally shown outstanding bars at amino acid residu masses. More details and parameters are described in the method documentation (<code><a href="../reference/plotMzDelta-methods.html">?plotMzDelta</a></code>). The <a href="#fig:plotMzDelta">next figure</a> has been generated using the PRIDE experiment 12011, as in <span class="citation">(Foster et al. 2011)</span>.</p>
<div class="figure">
<img src="Figures/plotMzDelta-pride12011.png" alt="Illustration of the plotMzDelta output for the PRIDE experiment 12011, as in figure 4A from (Foster et al. 2011)." id="fig:plotMzDelta"><p class="caption">Illustration of the <code>plotMzDelta</code> output for the PRIDE experiment 12011, as in figure 4A from <span class="citation">(Foster et al. 2011)</span>.</p>
</div>
<p>In section @ref(sec:incompdissoc), we illustrate how to assess incomplete reporter ion dissociation.</p>
</div>
<div id="sec:rawprocessing" class="section level1">
<h1 class="hasAnchor">
<a href="#sec:rawprocessing" class="anchor"></a>Raw data processing</h1>
<div id="sec:clean" class="section level2">
<h2 class="hasAnchor">
<a href="#sec:clean" class="anchor"></a>Cleaning spectra</h2>
<p>There are several methods implemented to perform basic raw data processing and manipulation. Low intensity peaks can be set to 0 with the <code>removePeaks</code> method from spectra or whole experiments. The intensity threshold below which peaks are removed is defined by the <code>t</code> parameter. <code>t</code> can be specified directly as a numeric. The default value is the character <code>"min"</code>, that will remove all peaks equal to the lowest non null intensity in any spectrum. We observe the effect of the <code>removePeaks</code> method by comparing total ion count (i.e. the total intensity in a spectrum) with the <code>ionCount</code> method before (object <code>itraqdata</code>) and after (object <code>experiment</code>) for spectrum <code>X55</code>. The respective spectra are shown on figure @ref(fig:spectrum-clean-plot).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">experiment &lt;-<span class="st"> </span><span class="kw"><a href="../reference/removePeaks-methods.html">removePeaks</a></span>(itraqdata, <span class="dt">t =</span> <span class="dv">400</span>, <span class="dt">verbose =</span> <span class="ot">FALSE</span>)
<span class="kw"><a href="../reference/Spectrum-class.html">ionCount</a></span>(itraqdata[[<span class="st">"X55"</span>]])</code></pre></div>
<pre><code>## [1] 555408.8</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/Spectrum-class.html">ionCount</a></span>(experiment[[<span class="st">"X55"</span>]])</code></pre></div>
<pre><code>## [1] 499769.6</code></pre>
<div class="figure">
<img src="MSnbase-demo_files/figure-html/spectrum-clean-plot-1.png" alt="Same spectrum before (left) and after setting peaks &lt;= 400 to 0." width="700"><p class="caption">
Same spectrum before (left) and after setting peaks &lt;= 400 to 0.
</p>
</div>
<p>Unlike the name might suggest, the <code>removePeaks</code> method does not actually remove peaks from the spectrum; they are set to 0. This can be checked using the <code>peaksCount</code> method, that returns the number of peaks (including 0 intensity peaks) in a spectrum. To effectively remove 0 intensity peaks from spectra, and reduce the size of the data set, one can use the <code>clean</code> method. The effect of the <code>removePeaks</code> and <code>clean</code> methods are illustrated on figure @ref(fig:preprocPlot).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/Spectrum-class.html">peaksCount</a></span>(itraqdata[[<span class="st">"X55"</span>]])</code></pre></div>
<pre><code>## [1] 1726</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/Spectrum-class.html">peaksCount</a></span>(experiment[[<span class="st">"X55"</span>]])</code></pre></div>
<pre><code>## [1] 1726</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">experiment &lt;-<span class="st"> </span><span class="kw"><a href="../reference/clean-methods.html">clean</a></span>(experiment, <span class="dt">verbose =</span> <span class="ot">FALSE</span>)
<span class="kw"><a href="../reference/Spectrum-class.html">peaksCount</a></span>(experiment[[<span class="st">"X55"</span>]])</code></pre></div>
<pre><code>## [1] 440</code></pre>
<div class="figure">
<img src="MSnbase-demo_files/figure-html/preprocPlot-1.png" alt="This figure illustrated the effect or the `removePeaks` and `clean` methods. The left-most spectrum displays two peaks, of max height 3 and 7 respectively. The middle spectrum shows the result of calling `removePeaks` with argument `t=3`, which sets all data points of the first peak, whose maximum height is smaller or equal to `t` to 0. The second peak is unaffected. Calling `clean` after `removePeaks` effectively deletes successive 0 intensities from the spectrum, as shown on the right plot." width="700"><p class="caption">
This figure illustrated the effect or the <code>removePeaks</code> and <code>clean</code> methods. The left-most spectrum displays two peaks, of max height 3 and 7 respectively. The middle spectrum shows the result of calling <code>removePeaks</code> with argument <code>t=3</code>, which sets all data points of the first peak, whose maximum height is smaller or equal to <code>t</code> to 0. The second peak is unaffected. Calling <code>clean</code> after <code>removePeaks</code> effectively deletes successive 0 intensities from the spectrum, as shown on the right plot.
</p>
</div>
</div>
<div id="sec:trim" class="section level2">
<h2 class="hasAnchor">
<a href="#sec:trim" class="anchor"></a>Focusing on specific MZ values</h2>
<p>Another useful manipulation method is <code>trimMz</code>, that takes as parameters and <em>MSnExp</em> (or a <em>Spectrum</em>) and a numeric <code>mzlim</code>. MZ values smaller then <code>min(mzlim)</code> or greater then <code>max(mzmax)</code> are discarded. This method is particularly useful when one wants to concentrate on a specific MZ range, as for reporter ions quantification, and generally results in substantial reduction of data size. Compare the size of the full trimmed experiment to the original 1.9 Mb.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">range</span>(<span class="kw"><a href="../reference/Spectrum-class.html">mz</a></span>(itraqdata[[<span class="st">"X55"</span>]]))</code></pre></div>
<pre><code>## [1] 100.0002 977.6636</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">experiment &lt;-<span class="st"> </span><span class="kw"><a href="../reference/trimMz-methods.html">filterMz</a></span>(experiment, <span class="dt">mzlim =</span> <span class="kw">c</span>(<span class="dv">112</span>,<span class="dv">120</span>))
<span class="kw">range</span>(<span class="kw"><a href="../reference/Spectrum-class.html">mz</a></span>(experiment[[<span class="st">"X55"</span>]]))</code></pre></div>
<pre><code>## [1] 102.0612 473.3372</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">experiment</code></pre></div>
<pre><code>## MSn experiment data ("MSnExp")
## Object size in memory: 1.18 Mb
## - - - Spectra data - - -
##  MS level(s): 2 
##  Number of spectra: 55 
##  MSn retention times: 19:9 - 50:18 minutes
## - - - Processing information - - -
## Data loaded: Wed May 11 18:54:39 2011 
## Updated from version 0.3.0 to 0.3.1 [Fri Jul  8 20:23:25 2016] 
## Curves &lt;= 400 set to '0': Thu May 17 15:35:42 2018 
## Spectra cleaned: Thu May 17 15:35:43 2018 
##  MSnbase version: 1.1.22 
## - - - Meta data  - - -
## phenoData
##   rowNames: 1
##   varLabels: sampleNames sampleNumbers
##   varMetadata: labelDescription
## Loaded from:
##   dummyiTRAQ.mzXML 
## protocolData: none
## featureData
##   featureNames: X1 X10 ... X9 (55 total)
##   fvarLabels: spectrum ProteinAccession ProteinDescription
##     PeptideSequence
##   fvarMetadata: labelDescription
## experimentData: use 'experimentData(object)'</code></pre>
<p>As can be seen above, all processing performed on the experiment is recorded and displayed as integral part of the experiment object.</p>
</div>
<div id="sec:specproc" class="section level2">
<h2 class="hasAnchor">
<a href="#sec:specproc" class="anchor"></a>Spectrum processing</h2>
<p><em>MSnExp</em> and <em>Spectrum2</em> instances also support standard MS data processing such as smoothing and peak picking, as described in the <code>smooth</code> and <code>pickPeak</code> manual pages. The methods that either single spectra of experiments, process the spectrum/spectra, and return a updated, processed, object. The implementations originate from the  package <span class="citation">(Gibb and Strimmer 2012)</span>.</p>
</div>
</div>
<div id="sec:isoquant" class="section level1">
<h1 class="hasAnchor">
<a href="#sec:isoquant" class="anchor"></a>MS2 isobaric tagging quantitation</h1>
<div id="sec:quant" class="section level2">
<h2 class="hasAnchor">
<a href="#sec:quant" class="anchor"></a>Reporter ions quantitation</h2>
<p>Quantitation is performed on fixed peaks in the spectra, that are specified with an <em>ReporterIons</em> object. A specific peak is defined by it’s expected <code>mz</code> value and is searched for within <code>mz</code> <span class="math inline">\(\pm\)</span> <code>width</code>. If no data is found, <code>NA</code> is returned.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/Spectrum-class.html">mz</a></span>(iTRAQ4)</code></pre></div>
<pre><code>## [1] 114.1112 115.1083 116.1116 117.1150</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/ReporterIons-class.html">width</a></span>(iTRAQ4)</code></pre></div>
<pre><code>## [1] 0.05</code></pre>
<p>The <code>quantify</code> method takes the following parameters: an <em>MSnExp</em> experiment, a character describing the quantification <code>method</code>, the <code>reporters</code> to be quantified and a <code>strict</code> logical defining whether data points ranging outside of <code>mz</code> <span class="math inline">\(\pm\)</span> <code>width</code> should be considered for quantitation. Additionally, a progress bar can be displaying when setting the <code>verbose</code> parameter to <code>TRUE</code>. Three quantification methods are implemented, as illustrated on figure @ref(fig:quantitationPlot). Quantitation using <code>sum</code> sums all the data points in the peaks to produce, for this example, 7, whereas method <code>max</code> only uses the peak’s maximum intensity, 3. <code>Trapezoidation</code> calculates the area under the peak taking the full with into account (using <code>strict = FALSE</code> gives 0.375) or only the width as defined by the reporter (using <code>strict = TRUE</code> gives 0.1). See <code><a href="../reference/quantify-methods.html">?quantify</a></code> for more details.</p>
<div class="figure">
<img src="MSnbase-demo_files/figure-html/quantitationPlot-1.png" alt="The different quantitation methods. See text for details." width="700"><p class="caption">
The different quantitation methods. See text for details.
</p>
</div>
<p>The <code>quantify</code> method returns <em>MSnSet</em> objects, that extend the well-known <em>eSet</em> class defined in the <em><a href="http://bioconductor.org/packages/Biobase">Biobase</a></em> package. <em>MSnSet</em> instances are very similar to <em>ExpressionSet</em> objects, except for the experiment meta-data that captures MIAPE specific information. The assay data is a matrix of dimensions <span class="math inline">\(n \times m\)</span>, where <span class="math inline">\(m\)</span> is the number of features/spectra originally in the <em>MSnExp</em> used as parameter in <code>quantify</code> and <span class="math inline">\(m\)</span> is the number of reporter ions, that can be accessed with the <code>exprs</code> method. The meta data is directly inherited from the <em>MSnExp</em> instance.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">qnt &lt;-<span class="st"> </span><span class="kw"><a href="../reference/quantify-methods.html">quantify</a></span>(experiment,
                <span class="dt">method =</span> <span class="st">"trap"</span>,
                <span class="dt">reporters =</span> iTRAQ4,
                <span class="dt">strict =</span> <span class="ot">FALSE</span>,
                <span class="dt">verbose =</span> <span class="ot">FALSE</span>)
qnt</code></pre></div>
<pre><code>## MSnSet (storageMode: lockedEnvironment)
## assayData: 55 features, 4 samples 
##   element names: exprs 
## protocolData: none
## phenoData
##   sampleNames: iTRAQ4.114 iTRAQ4.115 iTRAQ4.116 iTRAQ4.117
##   varLabels: mz reporters
##   varMetadata: labelDescription
## featureData
##   featureNames: X1 X10 ... X9 (55 total)
##   fvarLabels: spectrum ProteinAccession ... collision.energy (15
##     total)
##   fvarMetadata: labelDescription
## experimentData: use 'experimentData(object)'
## Annotation: No annotation 
## - - - Processing information - - -
## Data loaded: Wed May 11 18:54:39 2011 
## Updated from version 0.3.0 to 0.3.1 [Fri Jul  8 20:23:25 2016] 
## Curves &lt;= 400 set to '0': Thu May 17 15:35:42 2018 
## Spectra cleaned: Thu May 17 15:35:43 2018 
## iTRAQ4 quantification by trapezoidation: Thu May 17 15:35:45 2018 
##  MSnbase version: 1.1.22</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(<span class="kw">exprs</span>(qnt))</code></pre></div>
<pre><code>##     iTRAQ4.114 iTRAQ4.115 iTRAQ4.116 iTRAQ4.117
## X1   1347.6158  2247.3097  3927.6931  7661.1463
## X10   739.9861   799.3501   712.5983   940.6793
## X11 27638.3582 33394.0252 32104.2879 26628.7278
## X12 31892.8928 33634.6980 37674.7272 37227.7119
## X13 26143.7542 29677.4781 29089.0593 27902.5608
## X14  6448.0829  6234.1957  6902.8903  6437.2303</code></pre>
<p>The <a href="#fig:tmt10">next figure</a> illustrates the quantitation of the TMT 10-plex isobaric tags using the <code>quantify</code> method and the <code>TMT10</code> reporter instance. The data on the <span class="math inline">\(x\)</span> axis has been quantified using <code>method = "max"</code> and centroided data (as generated using ProteoWizard’s <code>msconvert</code> with vendor libraries’ peak picking); on the <span class="math inline">\(y\)</span> axis, the quantitation method was <code>trapezoidation</code> and <code>strict = TRUE</code> (that’s important for TMT 10-plex) and the profile data. We observe a very good correlation.</p>
<div class="figure">
<img src="Figures/tmt10comp.png" alt="TMT 10-plex quantitation." id="fig:tmt10"><p class="caption">TMT 10-plex quantitation.</p>
</div>
<p>If no peak is detected for a reporter ion peak, the respective quantitation value is set to <code>NA</code>. In our case, there is 1 such case in row 41. We will remove the offending line using the <code>filterNA</code> method. The <code>pNA</code> argument defines the percentage of accepted missing values per feature. As we do not expect any missing peaks, we set it to be 0 (which is also the detault value).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">table</span>(<span class="kw">is.na</span>(qnt))</code></pre></div>
<pre><code>## 
## FALSE  TRUE 
##   219     1</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">qnt &lt;-<span class="st"> </span><span class="kw"><a href="../reference/MSnSet-class.html">filterNA</a></span>(qnt, <span class="dt">pNA =</span> <span class="dv">0</span>)
<span class="kw">sum</span>(<span class="kw">is.na</span>(qnt))</code></pre></div>
<pre><code>## [1] 0</code></pre>
<p>The filtering criteria for <code>filterNA</code> can also be defined as a pattern of columns that can have missing values and columns that must not exhibit any. See <code><a href="../reference/MSnSet-class.html">?filterNA</a></code> for details and examples.</p>
<p>The infrastructure around the <em>MSnSet</em> class allows flexible filtering using the <code>[</code> sub-setting operator. Below, we mimic the behaviour of <code><a href="../reference/MSnSet-class.html">filterNA(, pNA = 0)</a></code> by calculating the row indices that should be removed, i.e. those that have at least one <code>NA</code> value and explicitly remove these rows. This method allows one to devise and easily apply any filtering strategy.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">whichRow &lt;-<span class="st"> </span><span class="kw">which</span>(<span class="kw">is.na</span>((qnt))) <span class="op">%%</span><span class="st"> </span><span class="kw">nrow</span>(qnt)
qnt &lt;-<span class="st"> </span>qnt[<span class="op">-</span>whichRow, ]</code></pre></div>
<p>See also the <code>plotNA</code> method to obtain a graphical overview of the completeness of a data set.</p>
</div>
<div id="sec:io2" class="section level2">
<h2 class="hasAnchor">
<a href="#sec:io2" class="anchor"></a>Importing quantitation data</h2>
<p>If quantitation data is already available as a spreadsheet, it can be imported, along with additional optional feature and sample (pheno) meta data, with the <code>readMSnSet</code> function. This function takes the respective text-based spreadsheet (comma- or tab-separated) file names as argument to create a valid <em>MSnSet</em> instance.</p>
<p>Note that the quantitation data of <em>MSnSet</em> objects can also be exported to a text-based spreadsheet file using the <code>write.exps</code> method.</p>
<p><em><a href="http://bioconductor.org/packages/MSnbase">MSnbase</a></em> also supports the <code>mzTab</code> format, a light-weight, tab-delimited file format for proteomics data. <code>mzTab</code> files can be read into R with <code>readMzTabData</code> to create and <em>MSnSet</em> instance.</p>
<p>See the <em>MSnbase-io</em> vignette for a general overview of <em><a href="http://bioconductor.org/packages/MSnbase">MSnbase</a></em>’s input/ouput capabilites.</p>
</div>
<div id="sec:io3" class="section level2">
<h2 class="hasAnchor">
<a href="#sec:io3" class="anchor"></a>Importing chromatographic data from SRM/MRM experiments</h2>
<p>Data from SRM/MRM experiments can be imported from <code>mzML</code> files using the <code>readSRMData</code> function. The <code>mzML</code> files are expected to contain chromatographic data for the same precursor and product m/z values. The function returns a <code>Chromatograms</code> object that arranges the data in a two-dimensional array, each column representing the data of one file (sample) and each row the chromatographic data for the same polarity, precursor and product m/z. In the example code below we load a single SRM file using <code>readSRMData</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fl &lt;-<span class="st"> </span><span class="kw"><a href="http://www.rdocumentation.org/packages/msdata/topics/proteomics">proteomics</a></span>(<span class="dt">full.names =</span> <span class="ot">TRUE</span>, <span class="dt">pattern =</span> <span class="st">"MRM"</span>)
srm &lt;-<span class="st"> </span><span class="kw"><a href="../reference/readSRMData.html">readSRMData</a></span>(fl)

srm</code></pre></div>
<pre><code>## Chromatograms with 137 rows and 1 column
##                     1
##        &lt;Chromatogram&gt;
## [1,]      length: 523
## [2,]      length: 523
## ...              ... 
## [136,]    length: 962
## [137,]    length: 962
## phenoData with 1 variables
## featureData with 10 variables</code></pre>
<p>The precursor and product m/z values can be extracted with the <code>precursorMz</code> and <code>productMz</code> functions. These functions always return a matrix, each row providing the lower and upper m/z value of the isolation window (in most cases minimal and maximal m/z will be identical).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(<span class="kw"><a href="../reference/Spectrum2-class.html">precursorMz</a></span>(srm))</code></pre></div>
<pre><code>##      mzmin mzmax
## [1,]   115   115
## [2,]   115   115
## [3,]   117   117
## [4,]   117   117
## [5,]   133   133
## [6,]   133   133</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(<span class="kw"><a href="../reference/Chromatogram-class.html">productMz</a></span>(srm))</code></pre></div>
<pre><code>##        mzmin   mzmax
## [1,]  26.996  26.996
## [2,]  70.996  70.996
## [3,]  72.996  72.996
## [4,]  98.996  98.996
## [5,] 114.996 114.996
## [6,]  70.996  70.996</code></pre>
</div>
<div id="sec:purcor" class="section level2">
<h2 class="hasAnchor">
<a href="#sec:purcor" class="anchor"></a>Peak adjustments</h2>
<p><strong>Single peak adjustment</strong> In certain cases, peak intensities need to be adjusted as a result of peak interferance. For example, the <span class="math inline">\(+1\)</span> peak of the phenylalanine (F, Phe) immonium ion (with <span class="math inline">\(m/z\)</span> 120.03) inteferes with the 121.1 TMT reporter ion. Below, we calculate the relative intensity of the +1 peaks compared to the main peak using the <em><a href="http://bioconductor.org/packages/Rdisop">Rdisop</a></em> package.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(Rdisop)
## Phenylalanine immonium ion
Fim &lt;-<span class="st"> </span><span class="kw"><a href="http://www.rdocumentation.org/packages/Rdisop/topics/getMolecule">getMolecule</a></span>(<span class="st">"C8H10N"</span>)
<span class="kw"><a href="http://www.rdocumentation.org/packages/Rdisop/topics/getMolecule">getMass</a></span>(Fim)</code></pre></div>
<pre><code>## [1] 120.0813</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">isotopes &lt;-<span class="st"> </span><span class="kw"><a href="http://www.rdocumentation.org/packages/Rdisop/topics/getMolecule">getIsotope</a></span>(Fim)
F1 &lt;-<span class="st"> </span>isotopes[<span class="dv">2</span>, <span class="dv">2</span>]
F1</code></pre></div>
<pre><code>## [1] 0.08573496</code></pre>
<p>If desired, one can thus specifically quantify the F immonium ion in the MS2 spectrum, estimate the intensity of the +1 ion (0.0857% of the F peak) and substract this calculated value from the 121.1 TMT reporter intensity.</p>
<p>The above principle can also be generalised for a set of overlapping peaks, as described below.</p>
<p><strong>Reporter ions purity correction</strong> Impurities in the reporter reagents can also bias the results and can be corrected when manufacturers provide correction coefficients. These generally come as percentages of each reporter ion that have masses differing by -2, -1, +1 and +2 Da from the nominal reporter ion mass due to isotopic variants. The <code>purityCorrect</code> method applies such correction to <em>MSnSet</em> instances. It also requires a square matrix as second argument, <code>impurities</code>, that defines the relative percentage of reporter in the quantified each peak. See <code><a href="../reference/purityCorrect-methods.html">?purityCorrect</a></code> for more details.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">impurities &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(<span class="fl">0.929</span>, <span class="fl">0.059</span>, <span class="fl">0.002</span>, <span class="fl">0.000</span>,
                       <span class="fl">0.020</span>, <span class="fl">0.923</span>, <span class="fl">0.056</span>, <span class="fl">0.001</span>,
                       <span class="fl">0.000</span>, <span class="fl">0.030</span>, <span class="fl">0.924</span>, <span class="fl">0.045</span>,
                       <span class="fl">0.000</span>, <span class="fl">0.001</span>, <span class="fl">0.040</span>, <span class="fl">0.923</span>),
                     <span class="dt">nrow =</span> <span class="dv">4</span>)
qnt.crct &lt;-<span class="st"> </span><span class="kw"><a href="../reference/purityCorrect-methods.html">purityCorrect</a></span>(qnt, impurities) 
<span class="kw">head</span>(<span class="kw">exprs</span>(qnt))</code></pre></div>
<pre><code>##     iTRAQ4.114 iTRAQ4.115 iTRAQ4.116 iTRAQ4.117
## X1   1347.6158  2247.3097  3927.6931  7661.1463
## X10   739.9861   799.3501   712.5983   940.6793
## X11 27638.3582 33394.0252 32104.2879 26628.7278
## X12 31892.8928 33634.6980 37674.7272 37227.7119
## X13 26143.7542 29677.4781 29089.0593 27902.5608
## X14  6448.0829  6234.1957  6902.8903  6437.2303</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(<span class="kw">exprs</span>(qnt.crct))</code></pre></div>
<pre><code>##     iTRAQ4.114 iTRAQ4.115 iTRAQ4.116 iTRAQ4.117
## X1   1304.7675  2168.1082  3784.2244  8133.9211
## X10   743.8159   806.5647   696.9024   988.0787
## X11 27547.6515 33592.3997 32319.1803 27413.1833
## X12 32127.1898 33408.8353 37806.0787 38658.7865
## X13 26187.3141 29788.6254 29105.2485 28936.6871
## X14  6533.1862  6184.1103  6945.2074  6666.5633</code></pre>
<p>The <code>makeImpuritiesMatrix</code> can be used to create impurity matrices. It opens a rudimentary spreadsheet that can be directly edited.</p>
</div>
</div>
<div id="sec:qproc" class="section level1">
<h1 class="hasAnchor">
<a href="#sec:qproc" class="anchor"></a>Processing quantitative data</h1>
<div id="sec:imp" class="section level2">
<h2 class="hasAnchor">
<a href="#sec:imp" class="anchor"></a>Data imputation</h2>
<p>A set of imputation methods are available in the <code>impute</code> method: it takes an <em>MSnSet</em> instance as input, the name of the imputation method to be applied (one of bpca, knn, QRILC, MLE, MinDet, MinProb, min, zero, mixed, nbavg), possible additional parameters and returns an updated for <em>MSnSet</em> without any missing values. Below, we apply a deterministic minimum value imputation on the <code>naset</code> example data:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## an example MSnSet containing missing values
<span class="kw">data</span>(naset)
<span class="kw">table</span>(<span class="kw">is.na</span>(naset))</code></pre></div>
<pre><code>## 
## FALSE  TRUE 
## 10254   770</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## number of NAs per protein
<span class="kw">table</span>(<span class="kw">fData</span>(naset)<span class="op">$</span>nNA) </code></pre></div>
<pre><code>## 
##   0   1   2   3   4   8   9  10 
## 301 247  91  13   2  23  10   2</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw"><a href="../reference/impute-methods.html">impute</a></span>(naset, <span class="st">"min"</span>)
<span class="kw"><a href="../reference/pSet-class.html">processingData</a></span>(x)</code></pre></div>
<pre><code>## - - - Processing information - - -
## Data imputation using min Thu May 17 15:35:47 2018 
##  MSnbase version: 1.15.6</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">table</span>(<span class="kw">is.na</span>(x))</code></pre></div>
<pre><code>## 
## FALSE 
## 11024</code></pre>
<p>As described in more details in <span class="citation">(Lazar et al. 2016)</span>, there are two types of mechanisms resulting in missing values in LC/MSMS experiments.</p>
<ul>
<li><p>Missing values resulting from absence of detection of a feature, despite ions being present at detectable concentrations. For example in the case of ion suppression or as a result from the stochastic, data-dependent nature of the MS acquisition method. These missing value are expected to be randomly distributed in the data and are defined as <em>missing at random</em> (MAR) or <em>missing completely at random</em> (MCAR).</p></li>
<li><p>Biologically relevant missing values, resulting from the <em>absence</em> of the low abundance of ions (below the limit of detection of the instrument). These missing values are not expected to be randomly distributed in the data and are defined as <em>missing not at random</em> (MNAR).</p></li>
</ul>
<p>MAR and MCAR values can be reasonably well tackled by many imputation methods. MNAR data, however, requires some knowledge about the underlying mechanism that generates the missing data, to be able to attempt data imputation. MNAR features should ideally be imputed with a <em>left-censor</em> (for example using a deterministic or probabilistic minimum value) method. Conversely, it is recommended to use <em>hot deck</em> methods (for example nearest neighbour, maximum likelihood, etc) when data are missing at random.</p>
<div class="figure">
<img src="MSnbase-demo_files/figure-html/miximp-1.png" alt="Mixed imputation method. Black cells represent presence of quantitation values and light grey corresponds to missing data. The two groups of interest are depicted in green and blue along the heatmap columns. Two classes of proteins are annotated on the left: yellow are proteins with randomly occurring missing values (if any) while proteins in brown are candidates for non-random missing value imputation." width="700"><p class="caption">
Mixed imputation method. Black cells represent presence of quantitation values and light grey corresponds to missing data. The two groups of interest are depicted in green and blue along the heatmap columns. Two classes of proteins are annotated on the left: yellow are proteins with randomly occurring missing values (if any) while proteins in brown are candidates for non-random missing value imputation.
</p>
</div>
<p>It is anticipated that the identification of both classes of missing values will depend on various factors, such as feature intensities and experimental design. Below, we use perform mixed imputation, applying nearest neighbour imputation on the 654 features that are assumed to contain randomly distributed missing values (if any) (yellow on figure @ref(fig:miximp)) and a deterministic minimum value imputation on the 35 proteins that display a non-random pattern of missing values (brown on figure @ref(fig:miximp)).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw"><a href="../reference/impute-methods.html">impute</a></span>(naset, <span class="dt">method =</span> <span class="st">"mixed"</span>,
            <span class="dt">randna =</span> <span class="kw">fData</span>(naset)<span class="op">$</span>randna,
            <span class="dt">mar =</span> <span class="st">"knn"</span>, <span class="dt">mnar =</span> <span class="st">"min"</span>)
x</code></pre></div>
<pre><code>## MSnSet (storageMode: lockedEnvironment)
## assayData: 689 features, 16 samples 
##   element names: exprs 
## protocolData: none
## phenoData
##   sampleNames: M1F1A M1F4A ... M2F11B (16 total)
##   varLabels: nNA
##   varMetadata: labelDescription
## featureData
##   featureNames: AT1G09210 AT1G21750 ... AT4G39080 (689 total)
##   fvarLabels: nNA randna
##   fvarMetadata: labelDescription
## experimentData: use 'experimentData(object)'
## Annotation:  
## - - - Processing information - - -
## Data imputation using mixed Thu May 17 15:35:48 2018 
##   Using default parameters 
##  MSnbase version: 1.15.6</code></pre>
<p>Please read <code><a href="../reference/impute-methods.html">?impute</a></code> for a description of the different methods.</p>
</div>
<div id="sec:norm" class="section level2">
<h2 class="hasAnchor">
<a href="#sec:norm" class="anchor"></a>Normalisation</h2>
<p>A <em>MSnSet</em> object is meant to be compatible with further downstream packages for data normalisation and statistical analysis. There is also a <code>normalise</code> (also available as <code>normalize</code>) method for expression sets. The method takes and instance of class <em>MSnSet</em> as first argument, and a character to describe the <code>method</code> to be used:</p>
<ul>
<li><p><code>quantiles</code>: Applies quantile normalisation <span class="citation">(B. M. Bolstad et al. 2003)</span> as implemented in the <code>normalize.quantiles</code> function of the <em><a href="http://bioconductor.org/packages/preprocessCore">preprocessCore</a></em> package.</p></li>
<li><p><code>quantiles.robust</code>: Applies robust quantile normalisation <span class="citation">(B. M. Bolstad et al. 2003)</span> as implemented in the <code>normalize.quantiles.robust</code> function of the <em><a href="http://bioconductor.org/packages/preprocessCore">preprocessCore</a></em> package.</p></li>
<li><p><code>vsn</code>: Applies variance stabilisation normalization <span class="citation">(Huber et al. 2002)</span> as implemented in the <code>vsn2</code> function of the <em><a href="http://bioconductor.org/packages/vsn">vsn</a></em> package.</p></li>
<li><p><code>max</code>: Each feature’s reporter intensity is divided by the maximum of the reporter ions intensities.</p></li>
<li><p><code>sum</code>: Each feature’s reporter intensity is divided by the sum of the reporter ions intensities.</p></li>
</ul>
<p>See <code><a href="../reference/normalise-methods.html">?normalise</a></code> for more methods. A <code>scale</code> method for <em>MSnSet</em> instances, that relies on the <code><a href="http://www.rdocumentation.org/packages/base/topics/scale">base::scale</a></code> function.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">qnt.max &lt;-<span class="st"> </span><span class="kw"><a href="../reference/normalise-methods.html">normalise</a></span>(qnt, <span class="st">"max"</span>)
qnt.sum &lt;-<span class="st"> </span><span class="kw"><a href="../reference/normalise-methods.html">normalise</a></span>(qnt, <span class="st">"sum"</span>)
qnt.quant &lt;-<span class="st"> </span><span class="kw"><a href="../reference/normalise-methods.html">normalise</a></span>(qnt, <span class="st">"quantiles"</span>)
qnt.qrob &lt;-<span class="st"> </span><span class="kw"><a href="../reference/normalise-methods.html">normalise</a></span>(qnt, <span class="st">"quantiles.robust"</span>)
qnt.vsn &lt;-<span class="st"> </span><span class="kw"><a href="../reference/normalise-methods.html">normalise</a></span>(qnt, <span class="st">"vsn"</span>)</code></pre></div>
<p>The effect of these are illustrated on figure @ref(fig:normPlot) and figure @ref(fig:cvPlot) reproduces figure 3 of <span class="citation">(Karp et al. 2010)</span> that described the application of vsn on iTRAQ reporter data.</p>
<div class="figure">
<img src="MSnbase-demo_files/figure-html/normPlot-1.png" alt="Comparison of the normalisation *MSnSet* methods. Note that vsn also glog-transforms the intensities." width="700"><p class="caption">
Comparison of the normalisation <em>MSnSet</em> methods. Note that vsn also glog-transforms the intensities.
</p>
</div>
<div class="figure">
<img src="MSnbase-demo_files/figure-html/cvPlot-1.png" alt="CV versus signal intensity comparison for log2 and vsn transformed data. Lines indicate running CV medians." width="700"><p class="caption">
CV versus signal intensity comparison for log2 and vsn transformed data. Lines indicate running CV medians.
</p>
</div>
<p>Note that it is also possible to normalise individual spectra or whole <em>MSnExp</em> experiments with the <code>normalise</code> method using the <code>max</code> method. This will rescale all peaks between 0 and 1. To visualise the relative reporter peaks, one should this first trim the spectra using method <code>trimMz</code> as illustrated in section @ref(sec:rawprocessing), then normalise the <em>MSnExp</em> with <code>normalise</code> using <code>method="max"</code> as illustrated above and plot the data using <code>plot</code> (figure @ref(fig:msnexpNormPlot)).</p>
<pre><code>## NULL</code></pre>
<p>Additional dedicated normalisation method are available for MS2 label-free quantitation, as described in section @ref(sec:lf) and in the <code>quantify</code> documentation.</p>
</div>
</div>
<div id="sec:feataggregation" class="section level1">
<h1 class="hasAnchor">
<a href="#sec:feataggregation" class="anchor"></a>Feature aggregation</h1>
<p>The above quantitation and normalisation has been performed on quantitative data obtained from individual spectra. However, the biological unit of interest is not the spectrum but the peptide or the protein. As such, it is important to be able to summarise features that belong to a same group, i.e. spectra from one peptide, peptides that originate from one protein, or directly combine all spectra that have been uniquely associated to one protein.</p>
<p><em><a href="http://bioconductor.org/packages/MSnbase">MSnbase</a></em> provides one function, <code>combineFeatures</code>, that allows to aggregate features stored in an <em>MSnSet</em> using build-in or user defined summary function and return a new <em>MSnSet</em> instance. The three main arguments are described below. Additional details can be found in the method documentation.</p>
<p><code>combineFeatures</code>’s first argument, <code>object</code>, is an instance of class <em>MSnSet</em>, as has been created in the section @ref(sec:quant) for instance. The second argument, <code>groupBy</code>, is a <code>factor</code> than has as many elements as there are features in the <em>MSnSet</em> <code>object</code> argument. The features corresponding to the <code>groupBy</code> levels will be aggregated so that the resulting <em>MSnSet</em> output will have <code><a href="../reference/pSet-class.html">length(levels(groupBy))</a></code> features. Here, we will combine individual MS2 spectra based on the protein they originate from. As shown below, this will result in 40 new aggregated features.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">gb &lt;-<span class="st"> </span><span class="kw">fData</span>(qnt)<span class="op">$</span>ProteinAccession
<span class="kw">table</span>(gb)</code></pre></div>
<pre><code>## gb
##     BSA ECA0172 ECA0435 ECA0452 ECA0469 ECA0621 ECA0631 ECA0691 ECA0871 
##       3       1       2       1       2       1       1       1       1 
## ECA0978 ECA1032 ECA1093 ECA1104 ECA1294 ECA1362 ECA1363 ECA1364 ECA1422 
##       1       1       1       1       1       1       1       1       1 
## ECA1443 ECA2186 ECA2391 ECA2421 ECA2831 ECA3082 ECA3175 ECA3349 ECA3356 
##       1       1       1       1       1       1       1       2       1 
## ECA3377 ECA3566 ECA3882 ECA3929 ECA3969 ECA4013 ECA4026 ECA4030 ECA4037 
##       1       2       1       1       1       1       2       1       1 
## ECA4512 ECA4513 ECA4514     ENO 
##       1       1       6       3</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/pSet-class.html">length</a></span>(<span class="kw">unique</span>(gb))</code></pre></div>
<pre><code>## [1] 40</code></pre>
<p>The third argument, <code>fun</code>, defined how to combine the features. Predefined functions are readily available and can be specified as strings (<code>fun="mean"</code>, <code>fun="median"</code>, <code>fun="sum"</code>, <code>fun="weighted.mean"</code> or <code>fun="medianpolish"</code> to compute respectively the mean, media, sum, weighted mean or median polish of the features to be aggregated). Alternatively, is is possible to supply user defined functions with <code>fun=function(x) { ... }</code>. We will use the <code>median</code> here.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">qnt2 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/combineFeatures.html">combineFeatures</a></span>(qnt, <span class="dt">groupBy =</span> gb, <span class="dt">fun =</span> <span class="st">"median"</span>)
qnt2</code></pre></div>
<pre><code>## MSnSet (storageMode: lockedEnvironment)
## assayData: 40 features, 4 samples 
##   element names: exprs 
## protocolData: none
## phenoData
##   sampleNames: iTRAQ4.114 iTRAQ4.115 iTRAQ4.116 iTRAQ4.117
##   varLabels: mz reporters
##   varMetadata: labelDescription
## featureData
##   featureNames: BSA ECA0172 ... ENO (40 total)
##   fvarLabels: spectrum ProteinAccession ... CV.iTRAQ4.117 (19
##     total)
##   fvarMetadata: labelDescription
## experimentData: use 'experimentData(object)'
## Annotation:  
## - - - Processing information - - -
## Data loaded: Wed May 11 18:54:39 2011 
## Updated from version 0.3.0 to 0.3.1 [Fri Jul  8 20:23:25 2016] 
## Curves &lt;= 400 set to '0': Thu May 17 15:35:42 2018 
## Spectra cleaned: Thu May 17 15:35:43 2018 
## iTRAQ4 quantification by trapezoidation: Thu May 17 15:35:45 2018 
## Subset [55,4][54,4] Thu May 17 15:35:45 2018 
## Removed features with more than 0 NAs: Thu May 17 15:35:45 2018 
## Dropped featureData's levels Thu May 17 15:35:46 2018 
## Combined 54 features into 40 using median: Thu May 17 15:35:48 2018 
##  MSnbase version: 2.7.1</code></pre>
<p>Of interest is also the <code>iPQF</code> spectra-to-protein summarisation method, which integrates peptide spectra characteristics and quantitative values for protein quantitation estimation. See <code><a href="../reference/iPQF.html">?iPQF</a></code> and references therein for details.</p>
</div>
<div id="sec:lf" class="section level1">
<h1 class="hasAnchor">
<a href="#sec:lf" class="anchor"></a>Label-free MS2 quantitation</h1>
<div id="peptide-counting" class="section level2">
<h2 class="hasAnchor">
<a href="#peptide-counting" class="anchor"></a>Peptide counting</h2>
<p>Note that if samples are not multiplexed, label-free MS2 quantitation by spectral counting is possible using <em><a href="http://bioconductor.org/packages/MSnbase">MSnbase</a></em>. Once individual spectra have been assigned to peptides and proteins (see section @ref(sec:id)), it becomes straightforward to estimate protein quantities using the simple peptide counting method, as illustrated in section @ref(sec:feataggregation).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sc &lt;-<span class="st"> </span><span class="kw"><a href="../reference/quantify-methods.html">quantify</a></span>(msexp, <span class="dt">method =</span> <span class="st">"count"</span>)
## lets modify out data for demonstration purposes
<span class="kw">fData</span>(sc)<span class="op">$</span>DatabaseAccess[<span class="dv">1</span>] &lt;-<span class="st"> </span><span class="kw">fData</span>(sc)<span class="op">$</span>DatabaseAccess[<span class="dv">2</span>]
<span class="kw">fData</span>(sc)<span class="op">$</span>DatabaseAccess</code></pre></div>
<pre><code>## [1] "ECA1028" "ECA1028" "ECA0510"</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sc &lt;-<span class="st"> </span><span class="kw"><a href="../reference/combineFeatures.html">combineFeatures</a></span>(sc, <span class="dt">groupBy =</span> <span class="kw">fData</span>(sc)<span class="op">$</span>DatabaseAccess,
                      <span class="dt">fun =</span> <span class="st">"sum"</span>)
<span class="kw">exprs</span>(sc)</code></pre></div>
<pre><code>##         dummyiTRAQ.mzXML
## ECA0510                1
## ECA1028                2</code></pre>
<p>Such count data could then be further analyses using dedicated count methods (originally developed for high-throughput sequencing) and directly available for <em>MSnSet</em> instances in the <em><a href="http://bioconductor.org/packages/msmsTests">msmsTests</a></em> Bioconductor package.</p>
</div>
<div id="spectral-counting-and-intensity-methods" class="section level2">
<h2 class="hasAnchor">
<a href="#spectral-counting-and-intensity-methods" class="anchor"></a>Spectral counting and intensity methods</h2>
<p>The spectral abundance factor (SAF) and the normalised form (NSAF) <span class="citation">(Paoletti et al. 2006)</span> as well as the spectral index (SI) and other normalised variations (SI<span class="math inline">\(_{GI}\)</span> and SI<span class="math inline">\(_N\)</span>) <span class="citation">(Griffin et al. 2010)</span> are also available. Below, we illustrate how to apply the normalised SI<span class="math inline">\(_N\)</span> to the experiment containing identification data produced in section @ref(sec:id).</p>
<p>The spectra that did not match any peptide have already been remove with the <code>removeNoId</code> method. As can be seen in the following code chunk, the first spectrum could not be matched to any single protein. Non-identified spectra and those matching multiple proteins are removed automatically prior to any label-free quantitation. Once can also remove peptide that do not match uniquely to proteins (as defined by the <code>nprot</code> feature variable column) with the <code>removeMultipleAssignment</code> method.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">fData</span>(msexp)[, <span class="kw">c</span>(<span class="st">"DatabaseAccess"</span>, <span class="st">"nprot"</span>)]</code></pre></div>
<pre><code>##       DatabaseAccess nprot
## F1.S1        ECA0984     1
## F1.S2        ECA1028     1
## F1.S5        ECA0510     1</code></pre>
<p>Note that the label-free methods implicitely apply feature aggregation (section @ref(sec:feataggregation)) and normalise (section @ref(sec:norm)) the quantitation values based on the total sample intensity and or the protein lengths (see <span class="citation">(Paoletti et al. 2006)</span> and <span class="citation">(Griffin et al. 2010)</span> for details).</p>
<p>Let’s now proceed with the quantitation using the <code>quantify</code>, as in section @ref(sec:quant), this time however specifying the method of interest, <code>SIn</code> (the <code>reporters</code> argument can of course be ignored here). The required peptide-protein mapping and protein lengths are extracted automatically from the feature meta-data using the default <code>accession</code> and <code>length</code> feature variables.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">siquant &lt;-<span class="st"> </span><span class="kw"><a href="../reference/quantify-methods.html">quantify</a></span>(msexp, <span class="dt">method =</span> <span class="st">"SIn"</span>)
<span class="kw"><a href="../reference/pSet-class.html">processingData</a></span>(siquant)</code></pre></div>
<pre><code>## - - - Processing information - - -
## Data loaded: Thu May 17 15:35:41 2018 
## Filtered 2 unidentified peptides out [Thu May 17 15:35:42 2018] 
## Quantitation by total ion current [Thu May 17 15:35:49 2018] 
## Combined 3 features into 3 using sum: Thu May 17 15:35:49 2018 
## Quantification by SIn [Thu May 17 15:35:49 2018] 
##  MSnbase version: 2.7.1</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">exprs</span>(siquant)</code></pre></div>
<pre><code>##         dummyiTRAQ.mzXML
## ECA0510     0.0006553518
## ECA0984     0.0035384487
## ECA1028     0.0002684726</code></pre>
<p>Other label-free methods can be applied by specifiying the appropriate <code>method</code> argument. See <code><a href="../reference/quantify-methods.html">?quantify</a></code> for more details.</p>
</div>
</div>
<div id="spectra-comparison" class="section level1">
<h1 class="hasAnchor">
<a href="#spectra-comparison" class="anchor"></a>Spectra comparison</h1>
<div id="plotting-two-spectra" class="section level2">
<h2 class="hasAnchor">
<a href="#plotting-two-spectra" class="anchor"></a>Plotting two spectra</h2>
<p><em><a href="http://bioconductor.org/packages/MSnbase">MSnbase</a></em> provides functionality to compare spectra against each other. The first notable function is <code>plot</code>. If two <em>Spectrum2</em> objects are provided <code>plot</code> will draw two plots: the upper and lower panel contain respectively the first and second spectrum. Common peaks are drawn in a slightly darker colour.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">centroided &lt;-<span class="st"> </span><span class="kw"><a href="../reference/pickPeaks-method.html">pickPeaks</a></span>(itraqdata, <span class="dt">verbose =</span> <span class="ot">FALSE</span>)
(k &lt;-<span class="st"> </span><span class="kw">which</span>(<span class="kw">fData</span>(centroided)[, <span class="st">"PeptideSequence"</span>] <span class="op">==</span><span class="st"> "TAGIQIVADDLTVTNPK"</span>))</code></pre></div>
<pre><code>## [1] 41 42</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mzk &lt;-<span class="st"> </span><span class="kw"><a href="../reference/Spectrum2-class.html">precursorMz</a></span>(centroided)[k]
zk &lt;-<span class="st"> </span><span class="kw"><a href="../reference/Spectrum2-class.html">precursorCharge</a></span>(centroided)[k]
mzk <span class="op">*</span><span class="st"> </span>zk</code></pre></div>
<pre><code>##      X46      X47 
## 2046.175 2045.169</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/plot-methods.html">plot</a></span>(centroided[[k[<span class="dv">1</span>]]], centroided[[k[<span class="dv">2</span>]]])</code></pre></div>
<div class="figure">
<img src="MSnbase-demo_files/figure-html/compms2plot-1.png" alt="Comparing two MS2 spectra." width="700"><p class="caption">
Comparing two MS2 spectra.
</p>
</div>
</div>
<div id="comparison-metrics" class="section level2">
<h2 class="hasAnchor">
<a href="#comparison-metrics" class="anchor"></a>Comparison metrics</h2>
<p>Currently <em><a href="http://bioconductor.org/packages/MSnbase">MSnbase</a></em> supports three different metrics to compare spectra against each other: <code>common</code> to calculate the number of common peaks, <code>cor</code> to calculate the Pearson correlation and <code>dotproduct</code> to calculate the dot product. See <code><a href="../reference/compareSpectra-methods.html">?compareSpectra</a></code> to apply other arbitrary metrics.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/compareSpectra-methods.html">compareSpectra</a></span>(centroided[[<span class="dv">2</span>]], centroided[[<span class="dv">3</span>]],
               <span class="dt">fun =</span> <span class="st">"common"</span>)</code></pre></div>
<pre><code>## [1] 8</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/compareSpectra-methods.html">compareSpectra</a></span>(centroided[[<span class="dv">2</span>]], centroided[[<span class="dv">3</span>]],
               <span class="dt">fun =</span> <span class="st">"cor"</span>)</code></pre></div>
<pre><code>## [1] 0.1105021</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/compareSpectra-methods.html">compareSpectra</a></span>(centroided[[<span class="dv">2</span>]], centroided[[<span class="dv">3</span>]],
               <span class="dt">fun =</span> <span class="st">"dotproduct"</span>)</code></pre></div>
<pre><code>## [1] 0.1185025</code></pre>
<p><code>compareSpectra</code> supports <em>MSnExp</em> objects as well.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">compmat &lt;-<span class="st"> </span><span class="kw"><a href="../reference/compareSpectra-methods.html">compareSpectra</a></span>(centroided, <span class="dt">fun=</span><span class="st">"cor"</span>)
compmat[<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">5</span>]</code></pre></div>
<pre><code>##             X1        X10        X11        X12        X13
## X1          NA 0.07672973 0.38024702 0.51579989 0.46647324
## X10 0.07672973         NA 0.11050214 0.11162512 0.08611906
## X11 0.38024702 0.11050214         NA 0.47184437 0.47905818
## X12 0.51579989 0.11162512 0.47184437         NA 0.57909089
## X13 0.46647324 0.08611906 0.47905818 0.57909089         NA
## X14 0.09999703 0.01558385 0.12165400 0.12057251 0.11853321
## X15 0.03314059 0.00416184 0.01733228 0.04796236 0.03196115
## X16 0.39140514 0.06634870 0.42259036 0.45624614 0.45469020
## X17 0.37945538 0.07188420 0.52292845 0.44791250 0.43679447
## X18 0.55367861 0.10286983 0.56621755 0.66884285 0.64262061</code></pre>
<p>Below, we illustrate how to compare a set of spectra using a hierarchical clustering.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/plot-methods.html">plot</a></span>(<span class="kw">hclust</span>(<span class="kw">as.dist</span>(compmat)))</code></pre></div>
<p><img src="MSnbase-demo_files/figure-html/dendo-1.png" width="700"></p>
</div>
</div>
<div id="sec:incompdissoc" class="section level1">
<h1 class="hasAnchor">
<a href="#sec:incompdissoc" class="anchor"></a>Quantitative assessment of incomplete dissociation</h1>
<p>Quantitation using isobaric reporter tags assumes complete dissociation between the reporter group (red on the <a href="#fig:itraqchem">figure below</a>), balance group (blue) and peptide (the peptide reactive group is drawn in green). However, incomplete dissociation does occur and results in an isobaric tag (i.e reporter and balance groups) specific peaks.</p>
<div class="figure">
<img src="Figures/itraqchem.png" alt="iTRAQ 4-plex isobaric tags reagent consist of three parts: (1) a charged reporter group (MZ of 114, 115, 116 and 117) that is unique to each of the four reagents (red), (2) an uncharged mass balance group (28-31 Da) (blue)and (3) a peptide reactive group (NHS ester) that binds to the peptide. In case of incomplete dissociation, the reporter and balance groups produce a specific peaks at MZ 145." id="fig:itraqchem"><p class="caption">iTRAQ 4-plex isobaric tags reagent consist of three parts: (1) a charged reporter group (MZ of 114, 115, 116 and 117) that is unique to each of the four reagents (red), (2) an uncharged mass balance group (28-31 Da) (blue)and (3) a peptide reactive group (NHS ester) that binds to the peptide. In case of incomplete dissociation, the reporter and balance groups produce a specific peaks at MZ 145.</p>
</div>
<p><em><a href="http://bioconductor.org/packages/MSnbase">MSnbase</a></em> provides, among others, a <em>ReporterIons</em> object for iTRAQ 4-plex that includes the 145 peaks, called <em>iTRAQ5</em>. This can then be used to quantify the experiment as show in section @ref(sec:quant) to estimate incomplete dissociation for each spectrum.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">iTRAQ5</code></pre></div>
<pre><code>## Object of class "ReporterIons"
## iTRAQ5: '4-plex iTRAQ and reporter + balance group' with 5 reporter ions
##  - 114.1112 +/- 0.05 (red)
##  - 115.1083 +/- 0.05 (green)
##  - 116.1116 +/- 0.05 (blue)
##  - 117.115 +/- 0.05 (yellow)
##  - 145.1 +/- 0.05 (grey)</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">incompdiss &lt;-<span class="st"> </span><span class="kw"><a href="../reference/quantify-methods.html">quantify</a></span>(itraqdata,
                       <span class="dt">method =</span> <span class="st">"trap"</span>,
                       <span class="dt">reporters =</span> iTRAQ5,
                       <span class="dt">strict =</span> <span class="ot">FALSE</span>,
                       <span class="dt">verbose =</span> <span class="ot">FALSE</span>)
<span class="kw">head</span>(<span class="kw">exprs</span>(incompdiss))</code></pre></div>
<pre><code>##     iTRAQ5.114 iTRAQ5.115 iTRAQ5.116 iTRAQ5.117 iTRAQ5.145
## X1   1347.6158  2247.3097  3927.6931  7661.1463  2063.8947
## X10   739.9861   799.3501   712.5983   940.6793   467.3615
## X11 27638.3582 33394.0252 32104.2879 26628.7278 13543.4565
## X12 31892.8928 33634.6980 37674.7272 37227.7119 11839.2558
## X13 26143.7542 29677.4781 29089.0593 27902.5608 12206.5508
## X14  6448.0829  6234.1957  6902.8903  6437.2303   427.6654</code></pre>
<p>Figure @ref(fig:incompdissPlot) compares these intensities for the whole experiment.</p>
<div class="figure">
<img src="MSnbase-demo_files/figure-html/incompdissPlot-1.png" alt="Boxplot and scatterplot comparing intensities of the 4 reporter ions (or their sum, on the right) and the incomplete dissociation specific peak." width="700"><p class="caption">
Boxplot and scatterplot comparing intensities of the 4 reporter ions (or their sum, on the right) and the incomplete dissociation specific peak.
</p>
</div>
</div>
<div id="sec:combine" class="section level1">
<h1 class="hasAnchor">
<a href="#sec:combine" class="anchor"></a>Combining <em>MSnSet</em> instances</h1>
<p>Combining mass spectrometry runs can be done in two different ways depending on the nature of these runs. If the runs represent repeated measures of identical samples, for instance multiple fractions, the data has to be combine along the row of the quantitation matrix: all the features (along the rows) represent measurements of the same set of samples (along the columns). In this situation, described in section @ref(sec:comb1), two experiments of dimensions <span class="math inline">\(n_1\)</span> (rows) by <span class="math inline">\(m\)</span> (columns and <span class="math inline">\(n_2\)</span> by <span class="math inline">\(m\)</span> will produce a new experiment of dimensions <span class="math inline">\(n_1 + n_2\)</span> by <span class="math inline">\(m\)</span>.</p>
<p>When however, different sets of samples have been analysed in different mass spectrometry runs, the data has to be combined along the columns of the quantitation matrix: some features will be shared across experiments and should thus be aligned on a same row in the new data set, whereas unique features to one experiment should be set as missing in the other one. In this situation, described in section @ref(sec:comb2), two experiments of dimensions <span class="math inline">\(n_1\)</span> by <span class="math inline">\(m_1\)</span> and <span class="math inline">\(n_2\)</span> by <span class="math inline">\(m_2\)</span> will produce a new experiment of dimensions <span class="math inline">\(unique_{n_1} + unique_{n_2} + shared_{n_1, n_2}\)</span> by <span class="math inline">\(m_1 + m_2\)</span>. The two first terms of the first dimension will be complemented by <code>NA</code> values.</p>
<p>Default <em>MSnSet</em> feature names (<code>X1</code>, <code>X2</code>, …) and sample names (<code>iTRAQ4.114</code>, <code>iTRAQ4.115</code>, <code>iTRAQ4.116</code>, …) are not informative. The features and samples of these anonymous quantitative data-sets should be updated before being combined, to guide how to meaningfully merge them.</p>
<div id="sec:comb1" class="section level2">
<h2 class="hasAnchor">
<a href="#sec:comb1" class="anchor"></a>Combining identical samples</h2>
<p>To simulate this situation, let us use quantiation data from the <code>itraqdata</code> object that is provided with the package as experiment 1 and the data from the <code>rawdata</code> <em>MSnExp</em> instance created at the very beginning of this document. Both experiments share the <em>same</em> default iTRAQ 4-plex reporter names as default sample names, and will thus automatically be combined along rows.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">exp1 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/quantify-methods.html">quantify</a></span>(itraqdata, <span class="dt">reporters =</span> iTRAQ4,
                 <span class="dt">verbose =</span> <span class="ot">FALSE</span>)
<span class="kw">sampleNames</span>(exp1)</code></pre></div>
<pre><code>## [1] "iTRAQ4.114" "iTRAQ4.115" "iTRAQ4.116" "iTRAQ4.117"</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/Spectrum-class.html">centroided</a></span>(rawdata) &lt;-<span class="st"> </span><span class="ot">FALSE</span>
exp2 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/quantify-methods.html">quantify</a></span>(rawdata, <span class="dt">reporters =</span> iTRAQ4,
                 <span class="dt">verbose =</span> <span class="ot">FALSE</span>)
<span class="kw">sampleNames</span>(exp2)</code></pre></div>
<pre><code>## [1] "iTRAQ4.114" "iTRAQ4.115" "iTRAQ4.116" "iTRAQ4.117"</code></pre>
<p>It important to note that the features of these independent experiments share the same default anonymous names: X1, X2, X3, …, that however represent quantitation of distinct physical analytes. If the experiments were to be combined as is, it would result in an error because data points for the same <em>feature</em> name (say <code>X1</code>) and the same <em>sample name</em> (say <code>iTRAQ4.114</code>) have different values. We thus first update the feature names to explicitate that they originate from different experiment and represent quantitation from different spectra using the convenience function <code>updateFeatureNames</code>. Note that updating the names of one experiment would suffice here.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(<span class="kw">featureNames</span>(exp1))</code></pre></div>
<pre><code>## [1] "X1"  "X10" "X11" "X12" "X13" "X14"</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">exp1 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/MSnSet-class.html">updateFeatureNames</a></span>(exp1)
<span class="kw">head</span>(<span class="kw">featureNames</span>(exp1))</code></pre></div>
<pre><code>## [1] "X1.exp1"  "X10.exp1" "X11.exp1" "X12.exp1" "X13.exp1" "X14.exp1"</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(<span class="kw">featureNames</span>(exp2))</code></pre></div>
<pre><code>## [1] "F1.S1" "F1.S2" "F1.S3" "F1.S4" "F1.S5"</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">exp2 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/MSnSet-class.html">updateFeatureNames</a></span>(exp2)
<span class="kw">head</span>(<span class="kw">featureNames</span>(exp2))</code></pre></div>
<pre><code>## [1] "F1.S1.exp2" "F1.S2.exp2" "F1.S3.exp2" "F1.S4.exp2" "F1.S5.exp2"</code></pre>
<p>The two experiments now share the same sample names and have different feature names and will be combined along the row. Note that all meta-data is correctly combined along the quantitation values.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">exp12 &lt;-<span class="st"> </span><span class="kw">combine</span>(exp1, exp2)</code></pre></div>
<pre><code>## Warning in combine(experimentData(x), experimentData(y)): 
##   unknown or conflicting information in MIAPE field 'email'; using information from first object 'x'</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/pSet-class.html">dim</a></span>(exp1)</code></pre></div>
<pre><code>## [1] 55  4</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/pSet-class.html">dim</a></span>(exp2)</code></pre></div>
<pre><code>## [1] 5 4</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/pSet-class.html">dim</a></span>(exp12)</code></pre></div>
<pre><code>## [1] 60  4</code></pre>
</div>
<div id="sec:comb2" class="section level2">
<h2 class="hasAnchor">
<a href="#sec:comb2" class="anchor"></a>Combine different samples</h2>
<p>Lets now create two <em>MSnSet</em>s from the same raw data to simulate two different independent experiments that share some features. As done previously (see section @ref(sec:feataggregation)), we combine the spectra based on the proteins they have been identified to belong to. Features can thus naturally be named using protein accession numbers. Alternatively, if peptide sequences would have been used as grouping factor in <code>combineFeatures</code>, then these would be good feature name candidates.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">1</span>)
i &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="kw"><a href="../reference/pSet-class.html">length</a></span>(itraqdata), <span class="dv">35</span>)
j &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="kw"><a href="../reference/pSet-class.html">length</a></span>(itraqdata), <span class="dv">35</span>)
exp1 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/quantify-methods.html">quantify</a></span>(itraqdata[i], <span class="dt">reporters =</span> iTRAQ4,
                 <span class="dt">verbose =</span> <span class="ot">FALSE</span>)
exp2 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/quantify-methods.html">quantify</a></span>(itraqdata[j], <span class="dt">reporters =</span> iTRAQ4,
                 <span class="dt">verbose =</span> <span class="ot">FALSE</span>)
exp1 &lt;-<span class="st"> </span><span class="kw">droplevels</span>(exp1)
exp2 &lt;-<span class="st"> </span><span class="kw">droplevels</span>(exp2)
<span class="kw">table</span>(<span class="kw">featureNames</span>(exp1) <span class="op">%in%</span><span class="st"> </span><span class="kw">featureNames</span>(exp2))</code></pre></div>
<pre><code>## 
## FALSE  TRUE 
##    12    23</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">exp1 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/combineFeatures.html">combineFeatures</a></span>(exp1,
                        <span class="dt">groupBy =</span> <span class="kw">fData</span>(exp1)<span class="op">$</span>ProteinAccession)</code></pre></div>
<pre><code>## Your data contains missing values. Please read the relevant
## section in the combineFeatures manual page for details the effects
## of missing values on data aggregation.</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">exp2 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/combineFeatures.html">combineFeatures</a></span>(exp2,
                        <span class="dt">groupBy =</span> <span class="kw">fData</span>(exp2)<span class="op">$</span>ProteinAccession)</code></pre></div>
<pre><code>## Your data contains missing values. Please read the relevant
## section in the combineFeatures manual page for details the effects
## of missing values on data aggregation.</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(<span class="kw">featureNames</span>(exp1))</code></pre></div>
<pre><code>## [1] "BSA"     "ECA0435" "ECA0469" "ECA0621" "ECA0631" "ECA0978"</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(<span class="kw">featureNames</span>(exp2))</code></pre></div>
<pre><code>## [1] "BSA"     "ECA0172" "ECA0435" "ECA0452" "ECA0469" "ECA0621"</code></pre>
<p>The <code>droplevels</code> drops the unused <code>featureData</code> levels. This is required to avoid passing absent levels as <code>groupBy</code> in <code>combineFeatures</code>. Alternatively, one could also use <code>factor(fData(exp1)\$ProteinAccession)</code> as <code>groupBy</code> argument.</p>
<p>The feature names are updated automatically by <code>combineFeatures</code>, using the <code>groupBy</code> argument. Proper feature names, reflecting the nature of the features (spectra, peptides or proteins) is critical when multiple experiments are to be combined, as this is done using common features as defined by their names (see below).</p>
<p>Sample names should also be updated to replace anonymous reporter names with relevant identifiers; the individual reporter data is stored in the <code>phenoData</code> and is not lost. A convenience function <code>updateSampleNames</code> is provided to append the <em>MSnSet</em>’s variable name to the already defined names, although in general, biologically relevant identifiers are preferred.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sampleNames</span>(exp1)</code></pre></div>
<pre><code>## [1] "iTRAQ4.114" "iTRAQ4.115" "iTRAQ4.116" "iTRAQ4.117"</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">exp1 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/MSnSet-class.html">updateSampleNames</a></span>(exp1)
<span class="kw">sampleNames</span>(exp1)</code></pre></div>
<pre><code>## [1] "iTRAQ4.114.exp1" "iTRAQ4.115.exp1" "iTRAQ4.116.exp1" "iTRAQ4.117.exp1"</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sampleNames</span>(exp1) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">"Ctrl1"</span>, <span class="st">"Cond1"</span>, <span class="st">"Ctrl2"</span>, <span class="st">"Cond2"</span>)
<span class="kw">sampleNames</span>(exp2) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">"Ctrl3"</span>, <span class="st">"Cond3"</span>, <span class="st">"Ctrl4"</span>, <span class="st">"Cond4"</span>)</code></pre></div>
<p>At this stage, it is not yet possible to combine the two experiments, because their feature data is not compatible yet; they share the same feature variable labels, i.e. the feature data column names (spectrum, ProteinAccession, ProteinDescription, …), but the part of the content is different because the original data was (in particular all the spectrum centric data: identical peptides in different runs will have different retention times, precursor intensities, …). Feature data with identical labels (columns in the data frame) and names (row in the data frame) are expected to have the same data and produce an error if not conform.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">stopifnot</span>(<span class="kw">all</span>(<span class="kw">fvarLabels</span>(exp1) <span class="op">==</span><span class="st"> </span><span class="kw">fvarLabels</span>(exp2)))
<span class="kw">fData</span>(exp1)[<span class="st">"BSA"</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">4</span>]</code></pre></div>
<pre><code>##     spectrum ProteinAccession   ProteinDescription PeptideSequence
## BSA        1              BSA bovine serum albumin          NYQEAK</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">fData</span>(exp2)[<span class="st">"BSA"</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">4</span>]</code></pre></div>
<pre><code>##     spectrum ProteinAccession   ProteinDescription PeptideSequence
## BSA       52              BSA bovine serum albumin       QTALVELLK</code></pre>
<p>Instead of removing these identical feature data columns, one can use a second convenience function, <code>updateFvarLabels</code>, to update feature labels based on the experiements variable name and maintain all the metadata.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">exp1 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/MSnSet-class.html">updateFvarLabels</a></span>(exp1)
exp2 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/MSnSet-class.html">updateFvarLabels</a></span>(exp2)
<span class="kw">head</span>(<span class="kw">fvarLabels</span>(exp1))</code></pre></div>
<pre><code>## [1] "spectrum.exp1"           "ProteinAccession.exp1"  
## [3] "ProteinDescription.exp1" "PeptideSequence.exp1"   
## [5] "fileIdx.exp1"            "retention.time.exp1"</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(<span class="kw">fvarLabels</span>(exp2))</code></pre></div>
<pre><code>## [1] "spectrum.exp2"           "ProteinAccession.exp2"  
## [3] "ProteinDescription.exp2" "PeptideSequence.exp2"   
## [5] "fileIdx.exp2"            "retention.time.exp2"</code></pre>
<p>It is now possible to combine <code>exp1</code> and <code>exp2</code>, including all the meta-data, with the <code>combine</code> method. The new experiment will contain the union of the feature names of the individual experiments with missing values inserted appropriately.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">exp12 &lt;-<span class="st"> </span><span class="kw">combine</span>(exp1, exp2)
<span class="kw"><a href="../reference/pSet-class.html">dim</a></span>(exp12)</code></pre></div>
<pre><code>## [1] 35  8</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">pData</span>(exp12)</code></pre></div>
<pre><code>##             mz reporters
## Ctrl1 114.1112    iTRAQ4
## Cond1 115.1083    iTRAQ4
## Ctrl2 116.1116    iTRAQ4
## Cond2 117.1150    iTRAQ4
## Ctrl3 114.1112    iTRAQ4
## Cond3 115.1083    iTRAQ4
## Ctrl4 116.1116    iTRAQ4
## Cond4 117.1150    iTRAQ4</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">exprs</span>(exp12)[<span class="dv">25</span><span class="op">:</span><span class="dv">28</span>, ]</code></pre></div>
<pre><code>##            Ctrl1    Cond1    Ctrl2     Cond2    Ctrl3    Cond3    Ctrl4
## ECA4513 10154.95 10486.94 11018.19 11289.552       NA       NA       NA
## ECA4514 20396.49 20832.98 23280.82 23693.574 15965.52 16206.91 18455.76
## ENO     50826.03 31978.10       NA  7528.967 39965.73 24967.40       NA
## ECA0172       NA       NA       NA        NA 17593.55 18545.62 19361.84
##             Cond4
## ECA4513        NA
## ECA4514 18704.058
## ENO      5925.663
## ECA0172 18328.237</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">exp12</code></pre></div>
<pre><code>## MSnSet (storageMode: lockedEnvironment)
## assayData: 35 features, 8 samples 
##   element names: exprs 
## protocolData: none
## phenoData
##   sampleNames: Ctrl1 Cond1 ... Cond4 (8 total)
##   varLabels: mz reporters
##   varMetadata: labelDescription
## featureData
##   featureNames: BSA ECA0435 ... ECA4512 (35 total)
##   fvarLabels: spectrum.exp1 ProteinAccession.exp1 ...
##     CV.iTRAQ4.117.exp2 (38 total)
##   fvarMetadata: labelDescription
## experimentData: use 'experimentData(object)'
## Annotation:  
## - - - Processing information - - -
## Combined [27,4] and [27,4] MSnSets Thu May 17 15:35:59 2018 
##  MSnbase version: 2.7.1</code></pre>
<p>In summary, when experiments with different samples need to be combined (along the columns), one needs to (1) clarify the sample names using <code>updateSampleNames</code> or better manually, for biological relevance and (2) update the feature data variable labels with <code>updateFvarLabels</code>. The individual experiments (there can be more than 2) can then easily be combined with the <code>combine</code> method while retaining the meta-data.</p>
<p>If runs for the same sample (different fractions for example) need to be combines, one needs to (1) differentiate the feature provenance with <code>updateFeatureNames</code> prior to use <code>combine</code>.</p>
</div>
<div id="sec:split" class="section level2">
<h2 class="hasAnchor">
<a href="#sec:split" class="anchor"></a>Splitting and unsplitting <em>MSnSet</em> instances</h2>
<p>A single <em>MSnSet</em> can also be split along the features/rows or samples/columns using the <code>split</code> method and a factor defining the splitting groups, resulting in an instance of class <em>MSnSetList</em>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">data</span>(dunkley2006)
<span class="kw">head</span>(<span class="kw">pData</span>(dunkley2006))</code></pre></div>
<pre><code>##        membrane.prep fraction replicate
## M1F1A              1        1         A
## M1F4A              1        4         A
## M1F7A              1        7         A
## M1F11A             1       11         A
## M1F2B              1        2         B
## M1F5B              1        5         B</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">split</span>(dunkley2006, dunkley2006<span class="op">$</span>replicate)</code></pre></div>
<pre><code>## Instance of class 'MSnSetList' containig 2 objects.</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## or, defining the appropriate annotation variable name
dun &lt;-<span class="st"> </span><span class="kw">split</span>(dunkley2006, <span class="st">"replicate"</span>)</code></pre></div>
<p>Above, we split along the columns/samples, but the function would equally work with a factor of length equal to the number of rows of the <em>MSnSet</em> (or a feature variable name) to split along the rows/features.</p>
<p>Finally, the effect of <code>split</code> can be reverted by <code>unsplit</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dun2 &lt;-<span class="st"> </span><span class="kw">unsplit</span>(dun, <span class="kw">pData</span>(dunkley2006)<span class="op">$</span>replicate)
<span class="kw"><a href="../reference/compareMSnSets.html">compareMSnSets</a></span>(dunkley2006, dun2)</code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<p>See <code><a href="../reference/MSnSetList-class.html">?MSnSetList</a></code> for more details about the class, <code>split</code> and <code>unsplit</code> and comments about storing multiple assays pertaining the same experiment.</p>
</div>
<div id="sec:avg" class="section level2">
<h2 class="hasAnchor">
<a href="#sec:avg" class="anchor"></a>Averaging <em>MSnSet</em> instances</h2>
<p>It is sometimes useful to average a set of replicated experiments to facilitate their visualisation. This can be easily achieved with the <code>averageMSnSet</code> function, which takes a list of valid <em>MSnSet</em> instances as input and creates a new object whose expression values are an average of the original values. A value of dispersion (<code>disp</code>) and a count of missing values (<code>nNA</code>) is recorded in the feature metadata slot. The average and dispersion are computed by default as the median and (non-parametric) coefficient of variation (see <code><a href="../reference/npcv.html">?npcv</a></code> for details), although this can easily be parametrised, as described in <code><a href="../reference/averageMSnSet.html">?averageMSnSet</a></code>.</p>
<p>The next code chunk illustrates the averaging function using three replicated experiments from <span class="citation">(Tan et al. 2009)</span> available in the <em><a href="http://bioconductor.org/packages/pRolocdata">pRolocdata</a></em> package.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(<span class="st">"pRolocdata"</span>)
<span class="kw">data</span>(tan2009r1)
<span class="kw">data</span>(tan2009r2)
<span class="kw">data</span>(tan2009r3)
msnl &lt;-<span class="st"> </span><span class="kw"><a href="../reference/MSnSetList-class.html">MSnSetList</a></span>(<span class="kw">list</span>(tan2009r1, tan2009r2, tan2009r3))
avgtan &lt;-<span class="st"> </span><span class="kw"><a href="../reference/averageMSnSet.html">averageMSnSet</a></span>(msnl)
<span class="kw">head</span>(<span class="kw">exprs</span>(avgtan))</code></pre></div>
<pre><code>##             X114      X115      X116      X117
## P20353 0.3605000 0.3035000 0.2095000 0.1265000
## P53501 0.4299090 0.1779700 0.2068280 0.1852625
## Q7KU78 0.1704443 0.1234443 0.1772223 0.5290000
## P04412 0.2567500 0.2210000 0.3015000 0.2205000
## Q7KJ73 0.2160000 0.1830000 0.3420000 0.2590000
## Q7JZN0 0.0965000 0.2509443 0.4771667 0.1750557</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(<span class="kw">fData</span>(avgtan)<span class="op">$</span>disp)</code></pre></div>
<pre><code>##               X114      X115        X116       X117
## P20353 0.076083495 0.1099127 0.109691169 0.14650198
## P53501 0.034172542 0.2640556 0.005139653 0.17104568
## Q7KU78 0.023198743 0.4483795 0.027883087 0.04764499
## P04412 0.053414021 0.2146751 0.090972139 0.27903810
## Q7KJ73 0.000000000 0.0000000 0.000000000 0.00000000
## Q7JZN0 0.007681865 0.1959534 0.097873350 0.06210542</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(<span class="kw">fData</span>(avgtan)<span class="op">$</span>nNA)</code></pre></div>
<pre><code>##        X114 X115 X116 X117
## P20353    1    1    1    1
## P53501    1    1    1    1
## Q7KU78    0    0    0    0
## P04412    1    1    1    1
## Q7KJ73    2    2    2    2
## Q7JZN0    0    0    0    0</code></pre>
<p>We are going to visualise the average data on a principle component (PCA) plot using the <code>plot2D</code> function from the <em><a href="http://bioconductor.org/packages/pRoloc">pRoloc</a></em> package <span class="citation">(Gatto et al. 2014)</span>. In addition, we are going to use the measure of dispersion to highlight averages with high variability by taking, for each protein, the maximum observed dispersion in the 4 samples. Note that in the default implementation, dispersions estimated from a single measurement (i.e. that had 2 missing values in our example) are set to 0; we will set these to the overal maximum observed dispersion.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">disp &lt;-<span class="st"> </span><span class="kw">rowMax</span>(<span class="kw">fData</span>(avgtan)<span class="op">$</span>disp)
disp[disp <span class="op">==</span><span class="st"> </span><span class="dv">0</span>] &lt;-<span class="st"> </span><span class="kw">max</span>(disp)
<span class="kw">range</span>(disp)</code></pre></div>
<pre><code>## [1] 0.01152877 1.20888923</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(<span class="st">"pRoloc"</span>)
<span class="kw"><a href="http://www.rdocumentation.org/packages/pRoloc/topics/plot2D">plot2D</a></span>(avgtan, <span class="dt">cex =</span> <span class="dv">3</span> <span class="op">*</span><span class="st"> </span>disp)</code></pre></div>
<div class="figure">
<img src="MSnbase-demo_files/figure-html/plot2Davg-1.png" alt="PCA plot of the averaged *MSnSet*. The point sizes are proportional to the dispersion of the protein quantitation across the averaged data." width="700"><p class="caption">
PCA plot of the averaged <em>MSnSet</em>. The point sizes are proportional to the dispersion of the protein quantitation across the averaged data.
</p>
</div>
</div>
</div>
<div id="sec:mse" class="section level1">
<h1 class="hasAnchor">
<a href="#sec:mse" class="anchor"></a>MS<sup>E</sup> data processing</h1>
<p><em><a href="http://bioconductor.org/packages/MSnbase">MSnbase</a></em> can also be used for MS<sup>E</sup> data independent acquisition from Waters instrument. The MS<sup>E</sup> pipeline depends on the Bioconductor <em><a href="http://bioconductor.org/packages/synapter">synapter</a></em> package <span class="citation">(Bond et al. 2013)</span> that produces <em>MSnSet</em> instances for indvidual acquisitions. The <em><a href="http://bioconductor.org/packages/MSnbase">MSnbase</a></em> infrastructure can subsequently be used to further combine experiments, as shown in section @ref(sec:comb2) and apply <em>top3</em> quantitation using the <code>topN</code> method.</p>
</div>
<div id="session-information" class="section level1 unnumbered">
<h1 class="hasAnchor">
<a href="#session-information" class="anchor"></a>Session information</h1>
<pre><code>## R Under development (unstable) (2018-04-02 r74505)
## Platform: x86_64-pc-linux-gnu (64-bit)
## Running under: Ubuntu 14.04.5 LTS
## 
## Matrix products: default
## BLAS: /usr/lib/atlas-base/atlas/libblas.so.3.0
## LAPACK: /usr/lib/lapack/liblapack.so.3.0
## 
## locale:
##  [1] LC_CTYPE=en_GB.UTF-8       LC_NUMERIC=C              
##  [3] LC_TIME=en_GB.UTF-8        LC_COLLATE=en_GB.UTF-8    
##  [5] LC_MONETARY=en_GB.UTF-8    LC_MESSAGES=en_GB.UTF-8   
##  [7] LC_PAPER=en_GB.UTF-8       LC_NAME=C                 
##  [9] LC_ADDRESS=C               LC_TELEPHONE=C            
## [11] LC_MEASUREMENT=en_GB.UTF-8 LC_IDENTIFICATION=C       
## 
## attached base packages:
##  [1] grid      stats4    parallel  stats     graphics  grDevices utils    
##  [8] datasets  methods   base     
## 
## other attached packages:
##  [1] gplots_3.0.1         msdata_0.21.0        pRoloc_1.21.0       
##  [4] MLInterfaces_1.61.1  cluster_2.0.7-1      annotate_1.59.0     
##  [7] XML_3.98-1.11        AnnotationDbi_1.43.1 IRanges_2.15.9      
## [10] S4Vectors_0.19.2     pRolocdata_1.19.0    Rdisop_1.41.0       
## [13] RcppClassic_0.9.9    zoo_1.8-1            MSnbase_2.7.1       
## [16] ProtGenerics_1.13.0  BiocParallel_1.15.3  mzR_2.15.1          
## [19] Rcpp_0.12.16         Biobase_2.41.0       BiocGenerics_0.27.0 
## [22] ggplot2_2.2.1        BiocStyle_2.9.0     
## 
## loaded via a namespace (and not attached):
##   [1] tidyselect_0.2.4      RSQLite_2.1.1         htmlwidgets_1.2      
##   [4] trimcluster_0.1-2     lpSolve_5.6.13        rda_1.0.2-2          
##   [7] munsell_0.4.3         codetools_0.2-15      preprocessCore_1.43.0
##  [10] withr_2.1.2           colorspace_1.3-2      BiocInstaller_1.31.1 
##  [13] highr_0.6             knitr_1.20            geometry_0.3-6       
##  [16] robustbase_0.93-0     dimRed_0.1.0          mzID_1.19.0          
##  [19] labeling_0.3          mnormt_1.5-5          hwriter_1.3.2        
##  [22] bit64_0.9-7           ggvis_0.4.3           rprojroot_1.3-2      
##  [25] ipred_0.9-6           xfun_0.1              randomForest_4.6-14  
##  [28] diptest_0.75-7        R6_2.2.2              doParallel_1.0.11    
##  [31] flexmix_2.3-14        DRR_0.0.3             bitops_1.0-6         
##  [34] assertthat_0.2.0      promises_1.0.1        scales_0.5.0         
##  [37] nnet_7.3-12           gtable_0.2.0          affy_1.59.0          
##  [40] ddalpha_1.3.3         timeDate_3043.102     rlang_0.2.0          
##  [43] CVST_0.2-1            genefilter_1.63.0     RcppRoll_0.2.2       
##  [46] splines_3.6.0         lazyeval_0.2.1        ModelMetrics_1.1.0   
##  [49] impute_1.55.0         hexbin_1.27.2         broom_0.4.4          
##  [52] yaml_2.1.19           reshape2_1.4.3        abind_1.4-5          
##  [55] threejs_0.3.1         crosstalk_1.0.0       backports_1.1.2      
##  [58] httpuv_1.4.3          caret_6.0-79          tools_3.6.0          
##  [61] lava_1.6.1            bookdown_0.7          psych_1.8.4          
##  [64] affyio_1.51.0         RColorBrewer_1.1-2    proxy_0.4-22         
##  [67] plyr_1.8.4            base64enc_0.1-3       progress_1.1.2       
##  [70] zlibbioc_1.27.0       purrr_0.2.4           RCurl_1.95-4.10      
##  [73] prettyunits_1.0.2     rpart_4.1-13          viridis_0.5.1        
##  [76] sampling_2.8          sfsmisc_1.1-2         fs_1.2.2             
##  [79] magrittr_1.5          pcaMethods_1.73.0     mvtnorm_1.0-7        
##  [82] whisker_0.3-2         mime_0.5              evaluate_0.10.1      
##  [85] xtable_1.8-2          mclust_5.4            gridExtra_2.3        
##  [88] compiler_3.6.0        biomaRt_2.37.0        tibble_1.4.2         
##  [91] KernSmooth_2.23-15    crayon_1.3.4          htmltools_0.3.6      
##  [94] later_0.7.2           tidyr_0.8.0           lubridate_1.7.4      
##  [97] DBI_1.0.0             magic_1.5-8           MASS_7.3-50          
## [100] fpc_2.1-11            Matrix_1.2-14         vsn_3.49.0           
## [103] gdata_2.18.0          mlbench_2.1-1         bindr_0.1.1          
## [106] gower_0.1.2           igraph_1.2.1          pkgconfig_2.0.1      
## [109] pkgdown_1.0.0         foreign_0.8-70        recipes_0.1.2        
## [112] MALDIquant_1.17       xml2_1.2.0            roxygen2_6.0.1       
## [115] foreach_1.4.4         prodlim_2018.04.18    stringr_1.3.1        
## [118] digest_0.6.15         pls_2.6-0             rmarkdown_1.9        
## [121] dendextend_1.8.0      kernlab_0.9-26        shiny_1.0.5          
## [124] gtools_3.5.0          commonmark_1.5        modeltools_0.2-21    
## [127] nlme_3.1-137          bindrcpp_0.2.2        desc_1.2.0           
## [130] viridisLite_0.3.0     limma_3.37.1          pillar_1.2.2         
## [133] lattice_0.20-35       httr_1.3.1            DEoptimR_1.0-8       
## [136] survival_2.42-3.1     glue_1.2.0            FNN_1.1              
## [139] gbm_2.1.3             prabclus_2.2-6        iterators_1.0.9      
## [142] bit_1.1-12            class_7.3-14          stringi_1.2.2        
## [145] blob_1.1.1            caTools_1.17.1        memoise_1.1.0        
## [148] dplyr_0.7.4           e1071_1.6-8</code></pre>
</div>
<div id="references" class="section level1 unnumbered">
<h1 class="hasAnchor">
<a href="#references" class="anchor"></a>References</h1>
<div id="refs" class="references">
<div id="ref-Bolstad03">
<p>Bolstad, B M, R A Irizarry, M Astrand, and T P Speed. 2003. “A Comparison of Normalization Methods for High Density Oligonucleotide Array Data Based on Variance and Bias.” <em>Bioinformatics</em> 19 (2): 185–93.</p>
</div>
<div id="ref-Bond2013">
<p>Bond, N J, P V Shliaha, K S Lilley, and L Gatto. 2013. “Improving Qualitative and Quantitative Performance for MS<span class="math inline">\(^E\)</span>-Based Label-Free Proteomics.” <em>J Proteome Res</em> 12 (6): 2340–53. doi:<a href="https://doi.org/10.1021/pr300776t">10.1021/pr300776t</a>.</p>
</div>
<div id="ref-Foster11">
<p>Foster, Joseph M, Sven Degroeve, Laurent Gatto, Matthieu Visser, Rui Wang, Johannes Griss, Rolf Apweiler, and Lennart Martens. 2011. “A Posteriori Quality Control for the Curation and Reuse of Public Proteomics Data.” <em>Proteomics</em> 11 (11): 2182–94. doi:<a href="https://doi.org/10.1002/pmic.201000602">10.1002/pmic.201000602</a>.</p>
</div>
<div id="ref-Gatto2014">
<p>Gatto, L, L M Breckels, S Wieczorek, T Burger, and K S Lilley. 2014. “Mass-Spectrometry-Based Spatial Proteomics Data Analysis Using pRoloc and pRolocdata.” <em>Bioinformatics</em> 30 (9): 1322–4. doi:<a href="https://doi.org/10.1093/bioinformatics/btu013">10.1093/bioinformatics/btu013</a>.</p>
</div>
<div id="ref-Gatto2012">
<p>Gatto, Laurent, and Kathryn S Lilley. 2012. “MSnbase – an R/Bioconductor Package for Isobaric Tagged Mass Spectrometry Data Visualization, Processing and Quantitation.” <em>Bioinformatics</em> 28 (2): 288–9. doi:<a href="https://doi.org/10.1093/bioinformatics/btr645">10.1093/bioinformatics/btr645</a>.</p>
</div>
<div id="ref-Gentleman2004">
<p>Gentleman, Robert C., Vincent J. Carey, Douglas M. Bates, Ben Bolstad, Marcel Dettling, Sandrine Dudoit, Byron Ellis, et al. 2004. “Bioconductor: Open Software Development for Computational Biology and Bioinformatics.” <em>Genome Biol</em> 5 (10): –80. doi:<a href="https://doi.org/10.1186/gb-2004-5-10-r80">10.1186/gb-2004-5-10-r80</a>.</p>
</div>
<div id="ref-Gibb2012">
<p>Gibb, S, and K Strimmer. 2012. “MALDIquant: A Versatile R Package for the Analysis of Mass Spectrometry Data.” <em>Bioinformatics</em> 28 (17): 2270–1. doi:<a href="https://doi.org/10.1093/bioinformatics/bts447">10.1093/bioinformatics/bts447</a>.</p>
</div>
<div id="ref-Griffin2010">
<p>Griffin, N M, J Yu, F Long, P Oh, S Shore, Y Li, J A Koziol, and J E Schnitzer. 2010. “Label-Free, Normalized Quantification of Complex Mass Spectrometry Data for Proteomic Analysis.” <em>Nat Biotechnol</em> 28 (1): 83–89. doi:<a href="https://doi.org/10.1038/nbt.1592">10.1038/nbt.1592</a>.</p>
</div>
<div id="ref-Huber2002">
<p>Huber, Wolfgang, Anja von Heydebreck, Holger Sueltmann, Annemarie Poustka, and Martin Vingron. 2002. “Variance Stabilization Applied to Microarray Data Calibration and to the Quantification of Differential Expression.” <em>Bioinformatics</em> 18 Suppl. 1: S96–S104.</p>
</div>
<div id="ref-Jones2012">
<p>Jones, Andrew R., Martin Eisenacher, Gerhard Mayer, Oliver Kohlbacher, Jennifer Siepen, Simon J. Hubbard, Julian N. Selley, et al. 2012. “The mzIdentML Data Standard for Mass Spectrometry-Based Proteomics Results.” <em>Molecular &amp; Cellular Proteomics</em> 11 (7). doi:<a href="https://doi.org/10.1074/mcp.M111.014381">10.1074/mcp.M111.014381</a>.</p>
</div>
<div id="ref-Karp2010">
<p>Karp, Natasha A, Wolfgang Huber, Pawel G Sadowski, Philip D Charles, Svenja V Hester, and Kathryn S Lilley. 2010. “Addressing Accuracy and Precision Issues in iTRAQ Quantitation.” <em>Mol. Cell Proteomics</em> 9 (9): 1885–97. doi:<a href="https://doi.org/10.1074/mcp.M900628-MCP200">10.1074/mcp.M900628-MCP200</a>.</p>
</div>
<div id="ref-Lazar:2016">
<p>Lazar, C, L Gatto, M Ferro, C Bruley, and T Burger. 2016. “Accounting for the Multiple Natures of Missing Values in Label-Free Quantitative Proteomics Data Sets to Compare Imputation Strategies.” <em>J Proteome Res</em> 15 (4): 1116–25. doi:<a href="https://doi.org/10.1021/acs.jproteome.5b00981">10.1021/acs.jproteome.5b00981</a>.</p>
</div>
<div id="ref-Martens2010">
<p>Martens, Lennart, Matthew Chambers, Marc Sturm, Darren Kes sner, Fredrik Levander, Jim Shofstahl, Wilfred H Tang, et al. 2010. “MzML - a Community Standard for Mass Spectrometry Data.” <em>Molecular &amp; Cellular Proteomics : MCP</em>. doi:<a href="https://doi.org/10.1074/mcp.R110.000133">10.1074/mcp.R110.000133</a>.</p>
</div>
<div id="ref-Orchard2007">
<p>Orchard, Sandra, Luisa Montechi-Palazzi, Eric W Deutsch, Pierre-Alain Binz, Andrew R Jones, Norman Paton, Angel Pizarro, David M Creasy, Jérôme Wojcik, and Henning Hermjakob. 2007. “Five Years of Progress in the Standardization of Proteomics Data 4th Annual Spring Workshop of the Hupo-Proteomics Standards Initiative April 23-25, 2007 Ecole Nationale Supérieure (Ens), Lyon, France.” <em>Proteomics</em> 7 (19): 3436–40. doi:<a href="https://doi.org/10.1002/pmic.200700658">10.1002/pmic.200700658</a>.</p>
</div>
<div id="ref-Paoletti2006">
<p>Paoletti, A C, T J Parmely, C Tomomori-Sato, S Sato, D Zhu, R C Conaway, J W Conaway, L Florens, and M P Washburn. 2006. “Quantitative Proteomic Analysis of Distinct Mammalian Mediator Complexes Using Normalized Spectral Abundance Factors.” <em>Proc Natl Acad Sci U S A</em> 103 (50): 18928–33. doi:<a href="https://doi.org/10.1073/pnas.0606379103">10.1073/pnas.0606379103</a>.</p>
</div>
<div id="ref-Pedrioli2004">
<p>Pedrioli, Patrick G A, Jimmy K Eng, Robert Hubley, Mathijs Vogelzang, Eric W Deutsch, Brian Raught, Brian Pratt, et al. 2004. “A Common Open Representation of Mass Spectrometry Data and Its Application to Proteomics Research.” <em>Nat. Biotechnol.</em> 22 (11): 1459–66. doi:<a href="https://doi.org/10.1038/nbt1031">10.1038/nbt1031</a>.</p>
</div>
<div id="ref-Rstat">
<p>R Development Core Team. 2011. <em>R: A Language and Environment for Statistical Computing</em>. Vienna, Austria: R Foundation for Statistical Computing. <a href="http://www.R-project.org/" class="uri">http://www.R-project.org/</a>.</p>
</div>
<div id="ref-Tan2009">
<p>Tan, Denise J, Heidi Dvinge, Andy Christoforou, Paul Bertone, Alfonso A Martinez, and Kathryn S Lilley. 2009. “Mapping Organelle Proteins and Protein Complexes in Drosophila Melanogaster.” <em>J Proteome Res</em> 8 (6): 2667–78. doi:<a href="https://doi.org/10.1021/pr800866n">10.1021/pr800866n</a>.</p>
</div>
<div id="ref-Taylor2008">
<p>Taylor, Chris F, Pierre-Alain Binz, Ruedi Aebersold, Michel Affolter, Robert Barkovich, Eric W Deutsch, David M Horn, et al. 2008. “Guidelines for Reporting the Use of Mass Spectrometry in Proteomics.” <em>Nat. Biotechnol.</em> 26 (8): 860–1. doi:<a href="https://doi.org/10.1038/nbt0808-860">10.1038/nbt0808-860</a>.</p>
</div>
<div id="ref-Taylor2007">
<p>Taylor, Chris F., Norman W. Paton, Kathryn S. Lilley, Pierre-Alain Binz, Randall K. Julian, Andrew R. Jones, Weimin Zhu, et al. 2007. “The Minimum Information About a Proteomics Experiment (Miape).” <em>Nat Biotechnol</em> 25 (8). The HUPO Proteomics Standards Initiative, Wellcome Trust Genome Campus, Hinxton, Cambridgeshire CB10 1SD, UK. chris.taylor@ebi.ac.uk: 887–93. doi:<a href="https://doi.org/10.1038/nbt1329">10.1038/nbt1329</a>.</p>
</div>
<div id="ref-ggplot2">
<p>Wickham, Hadley. 2009. <em>Ggplot2: Elegant Graphics for Data Analysis</em>. Springer New York. <a href="http://had.co.nz/ggplot2/book" class="uri">http://had.co.nz/ggplot2/book</a>.</p>
</div>
</div>
</div>
<div class="footnotes">
<hr>
<ol>
<li id="fn1"><p>in R, open it with <code><a href="../articles/MSnbase-development.html">vignette("MSnbase-development")</a></code> or read it online <a href="https://bioconductor.org/packages/devel/bioc/vignettes/MSnbase/inst/doc/MSnbase-development.html">here</a><a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>in R, open it with <code><a href="../articles/benchmarking.html">vignette("benchmarking")</a></code> or read it online <a href="https://bioconductor.org/packages/devel/bioc/vignettes/MSnbase/inst/doc/benchmarking.html">here</a><a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>Mascot Generic Format, see <a href="http://www.matrixscience.com/help/data_file_help.html#GEN" class="uri">http://www.matrixscience.com/help/data_file_help.html#GEN</a><a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>Parallel support is provided by the <em><a href="http://bioconductor.org/packages/BiocParallel">BiocParallel</a></em> and various backends including multicore (forking), simple networf network of workstations (SNOW) using sockets, forking or MPI among others.<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>This part will be automatically updated when the object is modified with it’s <em>ad hoc</em> methods, as illustrated later.<a href="#fnref5">↩</a></p></li>
<li id="fn6"><p>The identification data can also be passed as dedicated identification objects such as <code>mzRident</code> from the <em><a href="http://bioconductor.org/packages/mzR">mzR</a></em> package or <code>mzID</code> from thr <em><a href="http://bioconductor.org/packages/mzID">mzID</a></em> package, or as a <code>data.frame</code> - see <code>?addIdentifionData</code> for details.<a href="#fnref6">↩</a></p></li>
<li id="fn7"><p>The code to generate the histograms has been contributed by Guangchuang Yu.<a href="#fnref7">↩</a></p></li>
</ol>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#foreword">Foreword</a></li>
      <li><a href="#questions-and-bugs">Questions and bugs</a></li>
      <li>
<a href="#sec:intro">Introduction</a><ul class="nav nav-pills nav-stacked">
<li><a href="#speed-and-memory-requirements">Speed and memory requirements</a></li>
      </ul>
</li>
      <li>
<a href="#sec:data">Data structure and content</a><ul class="nav nav-pills nav-stacked">
<li><a href="#sec:io">Importing experiments</a></li>
      <li><a href="#exporting-experimentsms-data">Exporting experiments/MS data</a></li>
      <li><a href="#sec:msnexp">MS experiments</a></li>
      <li><a href="#sec:spectra">Spectra objects</a></li>
      <li><a href="#sec:reporterions">Reporter ions</a></li>
      <li><a href="#sec:chromatograms">Chromatogram objects</a></li>
      </ul>
</li>
      <li>
<a href="#sec:plotting">Plotting raw data</a><ul class="nav nav-pills nav-stacked">
<li><a href="#sec:msmaps">MS data space</a></li>
      <li><a href="#sec:specplots">MS Spectra</a></li>
      <li><a href="#sec:chromplots">MS Chromatogram</a></li>
      </ul>
</li>
      <li>
<a href="#sec:id">Tandem MS identification data</a><ul class="nav nav-pills nav-stacked">
<li><a href="#adding-identification-data">Adding identification data</a></li>
      <li><a href="#filtering-identification-data">Filtering identification data</a></li>
      <li><a href="#sec:calcfrag">Calculate Fragments</a></li>
      </ul>
</li>
      <li><a href="#sec:qc">Quality control</a></li>
      <li>
<a href="#sec:rawprocessing">Raw data processing</a><ul class="nav nav-pills nav-stacked">
<li><a href="#sec:clean">Cleaning spectra</a></li>
      <li><a href="#sec:trim">Focusing on specific MZ values</a></li>
      <li><a href="#sec:specproc">Spectrum processing</a></li>
      </ul>
</li>
      <li>
<a href="#sec:isoquant">MS2 isobaric tagging quantitation</a><ul class="nav nav-pills nav-stacked">
<li><a href="#sec:quant">Reporter ions quantitation</a></li>
      <li><a href="#sec:io2">Importing quantitation data</a></li>
      <li><a href="#sec:io3">Importing chromatographic data from SRM/MRM experiments</a></li>
      <li><a href="#sec:purcor">Peak adjustments</a></li>
      </ul>
</li>
      <li>
<a href="#sec:qproc">Processing quantitative data</a><ul class="nav nav-pills nav-stacked">
<li><a href="#sec:imp">Data imputation</a></li>
      <li><a href="#sec:norm">Normalisation</a></li>
      </ul>
</li>
      <li><a href="#sec:feataggregation">Feature aggregation</a></li>
      <li>
<a href="#sec:lf">Label-free MS2 quantitation</a><ul class="nav nav-pills nav-stacked">
<li><a href="#peptide-counting">Peptide counting</a></li>
      <li><a href="#spectral-counting-and-intensity-methods">Spectral counting and intensity methods</a></li>
      </ul>
</li>
      <li>
<a href="#spectra-comparison">Spectra comparison</a><ul class="nav nav-pills nav-stacked">
<li><a href="#plotting-two-spectra">Plotting two spectra</a></li>
      <li><a href="#comparison-metrics">Comparison metrics</a></li>
      </ul>
</li>
      <li><a href="#sec:incompdissoc">Quantitative assessment of incomplete dissociation</a></li>
      <li>
<a href="#sec:combine">Combining <em>MSnSet</em> instances</a><ul class="nav nav-pills nav-stacked">
<li><a href="#sec:comb1">Combining identical samples</a></li>
      <li><a href="#sec:comb2">Combine different samples</a></li>
      <li><a href="#sec:split">Splitting and unsplitting <em>MSnSet</em> instances</a></li>
      <li><a href="#sec:avg">Averaging <em>MSnSet</em> instances</a></li>
      </ul>
</li>
      <li><a href="#sec:mse">MS<sup>E</sup> data processing</a></li>
      <li><a href="#session-information">Session information</a></li>
      <li><a href="#references">References</a></li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by Laurent Gatto, Johannes Rainer, Sebastian Gibb.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://pkgdown.r-lib.org/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  

  </body>
</html>
